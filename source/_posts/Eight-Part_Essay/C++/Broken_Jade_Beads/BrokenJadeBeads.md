---
title: 碎玉零珠———— C++
top_img: '111303012_p0.jpg'
cover: '120131650_p0.png'
categories: 
    - 八股文
      - C++
tags: 
    - C++
---

## const 修饰的函数能否重载？

* **const修饰的函数可以重载**。const成员函数既不能改变类内的数据成员，也无法调用非const的成员函数；const类对象只能调用const成员函数。非const对象无论是否是const成员函数都能调用，但是如果有重载的非const函数，非const对象会优先调用重载后的非const函数。

## const 与 static 关键字

### const

* const修饰符用来定义常量，具有不可变性。在类中，被const修饰的成员函数，不能修改类中的数据成员；
* **指针常量**指的是该指针本身是一个常量，不能被修改，但是指针指向的对象可以被修改；
* **常量指针**指的是这个指针指向的对象是一个常量，不能被修改，但是指针本身可以被修改。
* 如果 const 变量是在**全局作用域**中声明的，它将存储在**静态存储区**（Static Storage Area）中。
* 如果 const 变量是在**函数内部或代码块内部**声明的，它将存储在**栈**（Stack）上，在函数返回时释放。
* **const 修饰的字符串常量**存储在**常量存储区**，在程序运行期间保持不变。

### static

* static 变量在类的声明中不占用内存（未赋值），因此必须在.cpp文件中定义类静态变量以分配内存；
* 文件域的静态变量和类的静态成员变量**在main执行之前的静态初始化过程中分配内存并初始化**（已赋值）；
* 局部静态变量在**第一次使用时分配内存并初始化**；
* 赋予字面值时会在**编译阶段**就被初始化, 加载时将其映射到内存空间。

#### 静态数据的存储

* **全局（静态）存储区**：分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。
* 其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量**在程序执行之前**已经为0。
* 存储在静态数据区的变量会**在程序刚开始运行时**就完成初始化，也是**唯一**的一次初始化。
* 在 C++ 中 static 的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。

## malloc 与 new

* C使用malloc / free, C++使用new / delete, 前者是C语言中的库函数，后者是C++语言的运算符
* 对于自定义对象，malloc/free只进行分配内存和释放内存，无法调用其构造函数和析构函数
* 只有new/delete能做到，完成对象的空间分配和初始化，以及对象的销毁和释放空间
* 所有二者**不可混用**
* 具体区别如下：
  1. new分配内存空间无需指定分配内存大小，malloc需要；
  2. new返回类型指针，类型安全，malloc返回void*，再强制转换成所需要的类型；
  3. new是从自由存储区获得内存，malloc从堆中获取内存；
  4. 对于类对象，new会调用构造函数和析构函数，malloc不会（核心）。

## inline 与 define

### inline

* 使编译器在函数调用点上展开函数，可以避免函数调用的栈开销；
* 内联函数的**缺点**是可能造成代码膨胀，尤其是递归的函数，会造成大量内存开销，exe太大，占用CPU资源。此外，内联函数不方便调试，每次修改会重新编译头文件，增加编译时间。

### 二者区别

* define宏命令是在预处理阶段对命令进行替换，inline是在编译阶段在函数调用点处直接展开函数，节省了函数调用的栈开销；
* define**不会**对参数的类型进行检查的，因此会出现类型安全的问题。比如定义一个max命令，但是传递的时候可能会传递一个整数和一个字符串，就会出错；
* 内联函数在编译阶段会进行类型检查；
* 使用宏的时候可能要添加很多括号，比较容易出错。

## 各种排序算法的原理和时间复杂度

1. **快速排序**：一轮划分，选择一个基准值，小于该基准值的元素放到左边，大于的放在右边，此时该基准值在整个序列中的位置就确定了，接着递归地对左边子序列和右边子序列进行划分。时间复杂度O(nlogn)，最坏的时间复杂度是O(n^2)。**需要排序的对象越有序，快速排序的退化程度越高，即时间复杂度越趋向于O(n ^ 2)**；
2. **堆排序**：利用完全二叉树性质构造的一个一维数组，用数组下标代表结点，则一个结点的左孩子下标为2i+1,右孩子为2i+2，一个结点的父节点为(i-1)/2。堆排序的思想就是，构造一个最大堆或者最小堆，以最大堆为例，那么最大的值就是根节点，把这个最大值和最后一个结点交换，然后在从前n-1个结点中构造一个最大堆，再重复上述的操作，即每次将现有序列的最大值放在现有数组的最后一位，最后就会形成一个有序数组；求升序用最大堆，降序用最小堆。时间复杂度O(nlogn)；
3. **冒泡排序**：从前往后两两比较，逆序则交换，不断重复直到有序；时间复杂度O(n^2)，最好情况O(n)；
4. **插入排序**：类似打牌，从第二个元素开始，把每个元素插入前面有序的序列中；时间复杂度O(n^2)，最好情况O(n)；
5. **选择排序**：每次选择待排序列中的最小值和未排序列中的首元素交换；时间复杂度O(n^2);
6. **归并排序**：将整个序列划分成最小的>=2的等长序列，排序后再合并，再排序再合并，最后合成一个完整序列。时间复杂度O(nlogn)。
7. **希尔排序**：是插入排序的改进版，取一个步长划分为多个子序列进行排序，再合并（如135一个序列，246一个序列），时间复杂度O(n1.3)，最好O(n)，最坏O(n^2)；
8. **桶排序**：将数组分到有限数量的桶里。每个桶再个别排序，最后依次把各个桶中的记录列出来记得到有序序列。桶排序的平均时间复杂度为线性的O(N+C)，其中C = N * (logN - logM)，M为桶的数量。最好的情况下为O(N)。
