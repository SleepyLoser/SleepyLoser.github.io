---
title: 碎玉零珠———— C++
top_img: '111303012_p0.jpg'
cover: '120131650_p0.png'
categories: 
    - 八股文
      - C++
tags: 
    - C++
---

## const 修饰的函数能否重载？

* **const修饰的函数可以重载**。const成员函数既不能改变类内的数据成员，也无法调用非const的成员函数；const类对象只能调用const成员函数。非const对象无论是否是const成员函数都能调用，但是如果有重载的非const函数，非const对象会优先调用重载后的非const函数。

## const 与 static 关键字

### const

* const修饰符用来定义常量，具有不可变性。在类中，被const修饰的成员函数，不能修改类中的数据成员；
* **指针常量**指的是该指针本身是一个常量，不能被修改，但是指针指向的对象可以被修改；
* **常量指针**指的是这个指针指向的对象是一个常量，不能被修改，但是指针本身可以被修改。
* 如果 const 变量是在**全局作用域**中声明的，它将存储在**静态存储区**（Static Storage Area）中。
* 如果 const 变量是在**函数内部或代码块内部**声明的，它将存储在**栈**（Stack）上，在函数返回时释放。
* **const 修饰的字符串常量**存储在**常量存储区**，在程序运行期间保持不变。

#### const 修饰函数的参数

* 如果参数作输出用，不论它是什么数据类型，也不论它采用“指针传递”还是“引用传递”，都不能加const修饰，否则该参数将失去输出功能。
* 如果输入参数采用“指针传递”，那么加const修饰可以防止意外地改动该指针，起到保护作用。

``` CPP
void StringCopy(char*strDestination, const char *strSource);
```

* **对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const引用传递”，目的是提高效率**。例如将 `void Func(A a)` 改为 `void Func(const A &a)`。
* **对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性**。例如 `void Func(int x)` 不应该改为 `void Func(const int &x)` 。

#### const 修饰函数的返回值

* 如果给以“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针。例如如下函数：

``` CPP
const char* GetString(void);
```

* 如下语句将出现编译错误：

``` CPP
char* str = GetString();
```

* 正确的用法时：

``` CPP
const char* str = GetString();
```

* 如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const修饰没有任何价值。　例如：
不要将函数 `int GetInt(void)` 写成 `const int GetInt(void)`。
* 同理不要把函数 `A GetA(void)` 写成 `const A GetA(void)` ，其中A为用户自定义的数据类型。
* 如果返回值**不是**内部数据类型，将函数 `A GetA(void)` 改写为 `const A& GetA(void)` 的确能提高效率。
* 但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。
* 函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。

``` CPP
class A
{
　　A& operate = (const A &other); // 赋值函数
};
A  a, b, c;   // a, b, c 为A的对象
 
a = b = c;    // 正常的链式赋值
(a = b) = c;  // 不正常的链式赋值，但合法
```

* 如果将赋值函数的返回值加const修饰，那么该返回值的内容不允许被改动。上例中，语句 `a = b = c` 仍然正确，但是语句 `(a = b) = c` 则是非法的。

#### const 成员函数

* 任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其它非const成员函数，编译器将指出错误。
* 这无疑会提高程序的健壮性。以下程序中，类stack的成员函数GetCount仅用于计数，从逻辑上讲GetCount应当为const函数。编译器将指出GetCount函数中的错误。

#### 补充：const放在后面是什么意思？

``` CPP
AcGePoint3dstartPoint() const;
```

* const放在后面跟前面有区别么？准确的说const是修饰this指向的对象的
* 譬如，我们定义了

``` CPP
class A
{
public:
　　f(int p);
};
```

* 这里 `f` 函数其实有两个参数，第一个是 `A* const this` , 另一个才是int类型的参数
* 如果我们不想 `f` 函数改变参数的值，可以把函数原型改为 `f(const int)` ,但如果我们不允许 `f` 改变this指向的对象呢？因为this是隐含参数，const没法直接修饰它，就加在函数的后面了，表示this的类型是 `const A* const this`。
* const修饰 `*this` 是本质，至于说“表示该成员函数不会修改类的数据。否则会编译报错”之类的说法只是一个现象，根源就是因为 `*this` 是const类型的。

``` CPP
class  Stack
{
public:
    void Push(int elem);
    int Pop(void);
    int GetCount(void) const; // const 成员函数
private:
    int m_num;
    int m_data[100];
};
 
int Stack::GetCount(void) const
{
    ++m_num;      // 编译错误，企图修改数据成员m_num
    Pop();        // 编译错误，企图调用非const函数
    return m_num;
} 
```

### static

* static 变量在类的声明中不占用内存（未赋值），因此必须在.cpp文件中定义类静态变量以分配内存；
* 文件域的静态变量和类的静态成员变量**在main执行之前的静态初始化过程中分配内存并初始化**（已赋值）；
* 局部静态变量在**第一次使用时分配内存并初始化**；
* 赋予字面值时会在**编译阶段**就被初始化, 加载时将其映射到内存空间。

#### 静态数据的存储

* **全局（静态）存储区**：分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。
* 其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量**在程序执行之前**已经为0。
* 存储在静态数据区的变量会**在程序刚开始运行时**就完成初始化，也是**唯一**的一次初始化。
* 在 C++ 中 static 的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。

## volatile

## malloc 与 new

* C使用malloc / free, C++使用new / delete, 前者是C语言中的库函数，后者是C++语言的运算符
* 对于自定义对象，malloc/free只进行分配内存和释放内存，无法调用其构造函数和析构函数
* 只有new/delete能做到，完成对象的空间分配和初始化，以及对象的销毁和释放空间
* 所有二者**不可混用**
* 具体区别如下：
  1. new分配内存空间无需指定分配内存大小，malloc需要；
  2. new返回类型指针，类型安全，malloc返回void*，再强制转换成所需要的类型；
  3. new是从自由存储区获得内存，malloc从堆中获取内存；
  4. 对于类对象，new会调用构造函数和析构函数，malloc不会（核心）。

## inline 与 define

### inline

* 使编译器在函数调用点上展开函数，可以避免函数调用的栈开销；
* 内联函数的**缺点**是可能造成代码膨胀，尤其是递归的函数，会造成大量内存开销，exe太大，占用CPU资源。此外，内联函数不方便调试，每次修改会重新编译头文件，增加编译时间。

### 二者区别

* define宏命令是在预处理阶段对命令进行替换，inline是在编译阶段在函数调用点处直接展开函数，节省了函数调用的栈开销；
* define**不会**对参数的类型进行检查的，因此会出现类型安全的问题。比如定义一个max命令，但是传递的时候可能会传递一个整数和一个字符串，就会出错；
* 内联函数在编译阶段会进行类型检查；
* 使用宏的时候可能要添加很多括号，比较容易出错。

## 动态库与静态库的区别

<img src="动态库与静态库的区别.png" alt="动态库与静态库的区别" style="zoom:50%;">

## Struct与Class的区别

<img src="Struct与Class.jpg" alt="Struct与Class的区别" style="zoom:50%;">

## 两个线程各进行100次i++操作后i的值是多少

<img src="两个线程进行i++.jpg" alt="两个线程进行i++" style="zoom:50%;">

## 继承时一般要写类的哪些成员函数？

<img src="默认成员函数.png" alt="默认成员函数" style="zoom:50%;">

## 怎样让对象只能创建在栈/堆/内存池中

* 在c++中，类的对象建立分为两种，一种是静态建立，比如

``` CPP
A a;
```

* 另一种是动态建立，比如

``` CPP
A* ptr = new A;
```

* 这两种方式是有区别的。
* **静态建立类对象**： 是由编译器为对象在栈空间中分配内存，通过移动栈顶指针挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。这种方式是直接调用类的构造函数。
* **动态建立类对象**： 是用new关键字将对象建立在堆空间上，这个过程分两步走。首先是执行 operator new() 函数，在堆空间上搜索合适的内存并分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方式是间接的调用类的构造函数。

### 只在栈上分配内存

* **只有使用new运算符，对象才会建立在堆上**，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new，而后者我们是可以自行声明重写的。
* 因此，将operator new()设为私有即可禁止对象被new在堆上。
* 代码如下：

``` CPP
class A  
{
private:  
    void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的  
    void operator delete(void* ptr){}  // 重载了new就需要重载delete  
public:  
    A(){}  
    ~A(){}
};
```

### 只在堆上分配内存

* 首先要知道，当对象建立在栈上面时, 是由编译器分配内存空间的，当对象使用完以后，编译器会调用析构函数来释放对象所占的空间。
* 实际上，编译器在为类对象分配栈空间时, 会检查类的析构函数的访问性(其他非静态函数也会检查)，如果类的析构函数是私有的， 则编程器不会在栈空间上为类对象分配内存。
* 因此, 我们只需要将析构函数设为私有，类对象就无法建立在栈上了。
* 代码如下：

``` CPP
class A
{
public:
    A(){}
    void destroy(){delete this;}
private:
    ~A(){}
}
```

* **注意**：由于new表达式会在分配内存以后调用构造函数，因此构造函数必须是公有的。同时由于delete此时无法访问私有的析构函数，因此必须提供一个destroy函数，来进行内存空间的释放。

### 由此引发的其它问题

1. **无法解决继承问题**：为了实现多态，析构函数通常要设为virtual，因此析构函数不能设为private，此时我们可以使用protected， 这样，子类可以访问析构函数，而外部无法访问。
2. new 和 destroy 的对应关系容易引起误解，解决办法是将构造函数也设置为protected，然后提供一个create函数和destroy对应。

## 红黑树的插入与删除（速记版）

<img src="红黑树插入.jpg" alt="红黑树的插入" style="zoom:50%;">
<img src="红黑树删除.jpg" alt="红黑树的删除" style="zoom:50%;">
