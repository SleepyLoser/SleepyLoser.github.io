---
title: 左值、右值、纯右值、将亡值
top_img: '114291323_p0.png'
cover: '107162316_p0.png'
categories: 
    - 八股文
      - C++ 
tags: 
    - C++
---

## 左值、右值、纯右值、将亡值

* C++11使用下面两种独立的性质来区别类别：
    1. **拥有身份**：指代某个非临时对象。
    2. **可被移动**：可被右值引用类型匹配。
* 每个C++表达式只属于三种基本值类别中的一种：`左值 (lvalue)`、`纯右值 (prvalue)`、`将亡值 (xvalue)`
    1. 拥有身份且不可被移动的表达式被称作 `左值 (lvalue)` 表达式，指持久存在的对象或类型为左值引用类型的返还值。
    2. 拥有身份且可被移动的表达式被称作 `将亡值 (xvalue)` 表达式，一般是指类型为右值引用类型的返还值。
    3. 不拥有身份且可被移动的表达式被称作 `纯右值 (prvalue)` 表达式，也就是指纯粹的临时值（即使指代的对象是持久存在的）。
    4. 不拥有身份且不可被移动的表达式无法使用。
* 如此分类是因为移动语义的出现，需要对类别重新规范说明。例如不能简单定义说右值就是临时值（因为也可能是std::move过的对象，该代指对象并不一定是临时值）。
* **左值 :**

1. 左值是一个数据的表达式（如变量名或引用的指针），我们**可以获取到它的地址**，正常情况下是可以能够对它赋值
2. **定义const修饰后的左值，不能给它赋值**，但是可以取出它的地址
3. 左值可以出现在赋值符号（ " = " ）的左边，也可以出现在赋值符号(" = " )的右边
4. 左值具有持久的状态

``` CPP
int lValue = 5;
int* lValueP = new int();
const int lValueC = 10;
```

* **左值引用 :**

1. 左值引用是对左值的一种引用，相当于给左值取别名
2. 普通的左值引用不能引用右值，**但是const的左值引用可以引用右值**
3. 引用方法: 类型+&，例如： int& lvalueReferenceP = lValueP; 引用变量

``` CPP
int& lValueReference = lValue;
int*& lValueReferenceP = lValueP;
const int& lValueReferenceC_1 = 10; // const的左值引用，引用右值
const int& lValueReferenceC_2 = 10 + 20; // const的左值引用，引用右值
```

* **右值**

1. 右值也是一个数据表达式，右值是**字面常量**或者是求值过程中创建的**临时对象**
2. 右值的生命周期是短暂的，如：`字面常量`，`表达式返回值`，`函数返回值`（不是左值引用的返回值），`临时变量`，`匿名对象`等等
3. 右值不能出现在赋值符号的左边，右值也**不能取出地址**，更**不能对它赋值**

``` CPP
// 以下是常见的右值
x + y; // 表达式返回值
function(x, y); // 函数返回值
10; // 常量
```

* **右值引用**

1. 右值引用是给右值取别名，**所有的右值引用是不能引用左值**
2. **右值是不能取出地址的**，但是当右值**取别名后，这个右值会被存到特定的位置，且可以取到该值的地址**，也就是说右值引用值是一个左值
3. 右值引用会开辟一块空间去存右值，其中普通的右值引用是可以被修改这块空间的，const的右值引用时不可以被修改的

``` CPP
int&& rValueReference = x + y; // 正确
rValueReference = 20; // 正确，普通的右值引用可以被修改
int&& rValueReference = x; // 错误，右值引用不能引用左值
const int rValueReferenceC = 10;
rValueReferenceC = 30; // 错误，rValueReferenceC是const右值引用，不能被修改
// 标准库中的move函数可以将一个左值强制转换为右值
int&& rValueReference = move(x); // 正确，move将x转化为左值
```

### 右值引用和移动拷贝构造函数

* 为了解决**深拷贝**的问题，我们可以使用**移动构造函数**，移动构造函数本质是将参数右值中的资源给窃取过来，占为己有，这样就不用做深拷贝。本质上是窃取别人的资源来构造自己，然后作为右值直接释放掉。这样就不会去在堆区上拷贝构造新的资源。

* 使用移动拷贝构造函数后，源对象指向资源就被交换出去，**这些资源的所有权都归属到了新对象**，因此，如果**源对象是一个长期存在的对象的时候**，需要**谨慎使用移动拷贝构造函数**。调用移动拷贝构造函数创建出s2，s1的资源被转移到了s2，s1中没有指向任何资源，所以就**不能通过s1去寻找之前的资源**。

``` CPP
string s1("123456");
string s2(move(s1)); // s1此时为NULL
```

## 总结

* **左值（lvalue）** 指持久存在（有变量名）的对象或返还值类型为左值引用的返还值，是不可移动的。
* **右值（rvalue）** 包含了 `将亡值`、`纯右值`，是可移动（可被右值引用类型匹配）的值。
* 实际上C++ std::move函数的实现原理就是的强转成右值引用类型并返还之，因此该返还值会被判断为将亡值，更宽泛的说是被判定为右值。

``` CPP
Vector& func1();
Vector&& func2();
Vector func3();

int main()
{
    Vector v;

    v;              //左值表达式
    func1();        //左值表达式，返还值是临时的，返还类型是左值引用，因此被认为不可移动。
    func2();        //将亡值表达式，返还值是临时的，返还类型是右值引用，因此指代的对象即使非临时也会被认为可移动。
    func3();        //纯右值表达式，返还值为临时值。
    std::move(v)；  //将亡值表达式，std::move本质也是个函数，同上。
    Vector();       //纯右值表达式
}

```
