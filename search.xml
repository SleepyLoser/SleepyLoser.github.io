<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Cache对代码的影响</title>
      <link href="/2025/07/20/Eight-Part_Essay/Computer_Organization/The_Impact_Of_Cache_On_Code/TheImpactOfCacheOnCode/"/>
      <url>/2025/07/20/Eight-Part_Essay/Computer_Organization/The_Impact_Of_Cache_On_Code/TheImpactOfCacheOnCode/</url>
      
        <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><ul><li>代码片段一</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">10</span>][<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++)</span><br><span class="line">        array[i][j] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>代码片段二</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">10</span>][<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">        array[j][i] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>我们假设使用的L1 Cache Line大小是64字节，采用写分配及写回策略。继续假设数组 array 内存首地址是64字节对齐。</li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ul><li>在有了以上背景假设后，我们先分析下<code>片段1</code>导致的Cache Miss / Hit情况。</li><li>当执行 <code>array[0][0]</code> = 1 时，Cache 控制器发现 <code>array[0][0]</code> 的值不在Cache中，此时发生一次 Cache Miss。然后从主存中读取 <code>array[0][0]</code> 到 <code>array[0][15]</code> 的内存值到 Cache 中。</li><li>当执行访问 <code>array[0][1]</code> = 1 时会发生一次 Cache Hit。此时内存访问速度极快。接着继续往下执行，会一直 Cache Hit。</li><li>直到执行 <code>array[0][16]</code> = 1，此时会 Cache Miss。总结来说就是访问内存每发生一次 Cache Miss。接下来会发生15次 Cache Hit。</li><li>因此这种初始化方法<strong>Cache命中率很高</strong>。</li></ul><hr><ul><li>我们再来分析下<code>片段2</code>。</li><li>当执行 <code>array[0][0]</code> = 1 时，Cache 控制器发现 <code>array[0][0]</code> 的值不在 Cache 中，此时发生一次 Cache Miss。然后从主存中读取 <code>array[0][0]</code> 到 <code>array[0][15]</code> 的内存值到 Cache 中。</li><li>当执行访问 <code>array[1][0]</code> = 1 时依然发生一次 Cache Miss。一直执行到 <code>array[9][0]</code> = 1 依然是一次Cache Miss。</li><li>现在思考下，访问 <code>array[0][1]</code> 会是怎么情况呢？此时就需要考虑 Cache 的大小了。如果<strong>Cache大小大于数组 array 大小</strong>，Cache 此时相当于缓存了整个 array 数组的内容。那么后续访问其他元素，确实是 Cache Hit。似乎和片段1代码分析结果差不多。</li><li>但是如果 Cache 的大小很小，例如只有数组一半大小，那么 Cache 命中率就很明显会降低。同样的 Cache 大小，<code>片段1</code> 的代码依然会获得很高的cache命中率。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在大多数情况下，<code>片段1</code> 代码的性能比 <code>片段2</code> 好。因此我们倾向 <code>片段1</code> 代码的写法。</li><li>附 <a href="/Eight-Part_Essay/Computer_Organization/The_Basic_Principle_Of_Cache/">Cache 的基本原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache的基本原理</title>
      <link href="//Eight-Part_Essay/Computer_Organization/The_Basic_Principle_Of_Cache/"/>
      <url>//Eight-Part_Essay/Computer_Organization/The_Basic_Principle_Of_Cache/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要Cache"><a href="#为什么需要Cache" class="headerlink" title="为什么需要Cache"></a>为什么需要Cache</h2><h3 id="程序是如何运行起来的"><a href="#程序是如何运行起来的" class="headerlink" title="程序是如何运行起来的"></a>程序是如何运行起来的</h3><ul><li>程序是运行在 RAM（随机存储器） 之中，我们称之为 main memory（主存）。当我们需要运行一个进程的时候，首先会从磁盘设备（例如，eMMC、UFS、SSD等）中将可执行程序load到主存中，然后开始执行。</li><li>在CPU内部存在一堆的通用寄存器（register）。如果 CPU 需要将一个变量（假设地址是A）加1，一般分为以下3个步骤：<ol><li>CPU 从主存中读取地址 A 的数据到内部通用寄存器 x0（ARM64架构的通用寄存器之一）。</li><li>通用寄存器 x0 加1。</li><li>CPU 将通用寄存器 x0 的值写入主存。</li></ol></li></ul><p><img src="变量加一过程.png" alt="变量加一过程" style="zoom:100%;"></p><ul><li>其实现实中，CPU通用寄存器的速度（&lt; 1ns）和主存（~ 65ns）之间存在着太大的差异。</li><li>因此，上面举例的3个步骤中，步骤1和步骤3实际上速度很慢。当CPU试图从主存中 Load / Store 操作时，由于主存的速度限制，CPU不得不等待这漫长的65ns时间。</li><li>如果我们采用更快材料制作更快速度的主存，并且拥有几乎差不多的容量, 其成本将会大幅度上升。我们试图提升主存的速度和容量，又期望其成本很低，这就有点难为人了。</li><li>因此，我们有一种折中的方法，那就是制作一块速度极快但是容量极小的存储设备。那么其成本也不会太高。这块存储设备我们称之为<strong>Cache Memory</strong>。</li><li>在硬件上，我们将Cache放置在CPU和主存之间，作为主存数据的缓存。</li><li>当CPU试图从主存中 Load / Store数据的时候，CPU会首先从 Cache 中查找对应地址的数据是否缓存在 Cache 中。如果其数据缓存在 Cache 中，直接从 Cache 中拿到数据并返回给CPU。</li></ul><p><img src="变量加一过程(2).png" alt="变量加一过程(2)" style="zoom:100%;"></p><ul><li>CPU和主存之间直接数据传输的方式转变成 CPU 和 Cache 之间直接数据传输。Cache 负责和主存之间数据传输。</li></ul><h2 id="多级Cache存储结构"><a href="#多级Cache存储结构" class="headerlink" title="多级Cache存储结构"></a>多级Cache存储结构</h2><ul><li>当cache中没有缓存我们想要的数据的时候，依然需要漫长的等待从主存中load数据。为了进一步提升性能，引入多级cache。</li><li>前面提到的cache，称之为L1 cache（第一级cache）。我们在L1 cache 后面连接L2 cache，在L2 cache 和主存之间连接L3 cache。等级越高，速度越慢，容量越大。但是速度相比较主存而言，依然很快。</li><li>不同等级cache速度之间关系如下：</li></ul><p><img src="不同等级cache速度.png" alt="不同等级cache速度" style="zoom:100%;"></p><ul><li>经过3级cache的缓冲，各级cache和主存之间的速度差也逐级减小。</li></ul><h2 id="多级cache之间的配合工作"><a href="#多级cache之间的配合工作" class="headerlink" title="多级cache之间的配合工作"></a>多级cache之间的配合工作</h2><ul><li>首先引入两个名词概念，<code>命中</code>和<code>缺失</code>。CPU要访问的数据在cache中有缓存，称为<strong>命中</strong> (hit)，反之则称为<strong>缺失</strong> (miss)。</li><li>多级cache之间是如何配合工作的呢？我们假设现在考虑的系统只有两级cache。<ol><li>当CPU试图从某地址load数据时，首先从L1 cache中查询是否命中，如果命中则把数据返回给CPU。如果L1 cache缺失，则继续从L2 cache中查找。</li><li>当L2 cache命中时，数据会返回给L1 cache以及CPU。如果L2 cache也缺失，很不幸，我们需要从主存中load数据，将数据返回给L2 cache、L1 cache及CPU。</li></ol></li></ul><p><img src="多级Cache.jpg" alt="多级Cache" style="zoom:100%;"></p><ul><li>这种多级cache的工作方式称之为inclusive cache（包容性缓存），某一地址的数据可能存在多级缓存中。</li><li>与inclusive cache对应的是exclusive cache（独占缓存），这种cache保证某一地址的数据缓存只会存在于多级cache其中一级。也就是说，任意地址的数据不可能同时在 L1 和 L2 cache 中缓存。</li></ul><h2 id="直接映射缓存-Direct-mapped-cache"><a href="#直接映射缓存-Direct-mapped-cache" class="headerlink" title="直接映射缓存(Direct mapped cache)"></a>直接映射缓存(Direct mapped cache)</h2><ul><li>cache的大小称之为 <code>cache size</code>，代表cache可以缓存最大数据的大小。我们将cache平均分成相等的很多块，每一个块大小称之为 <code>cache line</code> ，其大小是 <code>cache line size</code> 。</li><li>例如一个64 Bytes大小的cache。如果我们将64 Bytes平均分成64块，那么cache line就是1字节，总共64行cache line。如果我们将64 Bytes平均分成8块，那么cache line就是8字节，总共8行cache line。</li><li>现在的硬件设计中，一般cache line的大小是4-128 Bytes。为什么没有1 byte呢？原因我们后面讨论。</li><li>注意，<strong>cache line是cache和主存之间数据传输的最小单位</strong>。什么意思呢？当CPU试图load一个字节数据的时候，如果cache缺失，那么cache控制器会从主存中<strong>一次性</strong>的load cache line大小的数据到cache中。</li><li>例如，cache line大小是8字节。CPU即使读取一个byte，在cache缺失后，cache会从主存中load 8字节填充整个cache line。又是因为什么呢？后面说完就懂了。</li><li>我们假设下面的讲解都是针对64 Bytes大小的cache，并且cache line大小是8字节。我们可以类似把这块cache想想成一个数组，数组总共8个元素，每个元素大小是8字节。就像下图这样。</li></ul><p><img src="Cache数组.jpg" alt="Cache数组" style="zoom:100%;"></p><ul><li>一个地址访问要映射到Cache中，地址被分成三个字段：tag，set index，block offset。这样，通过一个物理地址就可以获取数据或指令在缓存中的位置(set, way, byte)</li><li>现在我们考虑一个问题，CPU从0x0654地址读取一个字节，cache控制器是如何判断数据是否在cache中命中呢？我们<strong>如何根据地址在有限大小的cache中查找数据</strong>呢？现在硬件采取的做法是对地址进行<strong>散列</strong>（可以理解成地址取模操作）。</li></ul><p><img src="在Cache中寻找数据.jpg" alt="在Cache中寻找数据" style="zoom:100%;"></p><ul><li>我们一共有8行cache line，cache line大小是8 Bytes。所以我们可以利用地址低3 bits（如上图地址蓝色部分）用来寻址8 bytes中某一字节，我们称这部分bit组合为offset。</li><li>同理，8行cache line，为了覆盖所有行。我们需要3 bits（如上图地址黄色部分）查找某一行，这部分地址部分称之为index。</li><li>现在我们知道，如果两个不同的地址，其地址的bit3-bit5如果完全一样的话，那么这两个地址经过硬件散列之后都会找到同一个cache line。</li><li>所以，当我们找到cache line之后，只代表我们访问的地址对应的数据可能存在这个cache line中，但是也有可能是其他地址对应的数据。</li><li>为此，我们又引入tag array区域，tag array和data array一一对应。一个cache line都对应唯一一个tag，<strong>tag中保存的是整个地址位宽去除index和offset使用的bit剩余部分</strong>（如上图地址绿色部分）。</li><li>tag、index和offset三者组合就可以唯一确定一个地址了。因此，当我们根据地址中index位找到cache line后，<strong>取出当前cache line对应的tag，然后和地址中的tag进行比较</strong>，如果相等，这说明<strong>cache命中</strong>。如果不相等，说明当前cache line存储的是其他地址的数据，这就是<strong>cache缺失</strong>。</li><li>因此解答了我们之前的一个疑问<strong>为什么硬件cache line不做成一个字节？</strong>。这样会导致硬件成本的上升，因为原本8个字节对应一个tag，现在需要8个tag，占用了很多内存。tag也是cache的一部分，但是我们谈到cache size的时候并不考虑tag占用的内存部分。</li><li>我们可以从图中看到tag旁边还有一个<code>valid bit</code>，这个bit用来表示cache line中数据<strong>是否有效</strong>（例如：1代表有效；0代表无效）。当系统刚启动时，cache中的数据都应该是无效的，因为还没有缓存任何数据。cache控制器可以根据valid bit确认当前cache line数据是否有效。所以，上述比较tag确认cache line是否命中之前还会检查valid bit是否有效。只有在有效的情况下，比较tag才有意义。如果无效，直接判定cache缺失。</li><li>上面的例子中，cache size是64 Bytes并且cache line size是8 bytes。offset、index和tag分别使用3 bits、3 bits和42 bits（假设地址宽度是48 bits）。我们现在再看一个例子：512 Bytes cache size，64 Bytes cache line size。根据之前的地址划分方法，offset、index和tag分别使用6 bits、3 bits和39 bits。如下图所示。</li></ul><p><img src="在Cache中寻找数据(2).jpg" alt="在Cache中寻找数据(2)" style="zoom:100%;"></p><h2 id="直接映射缓存的优缺点"><a href="#直接映射缓存的优缺点" class="headerlink" title="直接映射缓存的优缺点"></a>直接映射缓存的优缺点</h2><p><img src="直接映射缓存的优缺点.png" alt="直接映射缓存" style="zoom:50%;"></p><ul><li>我们可以看到，地址0x00-0x3f地址处对应的数据可以覆盖整个cache。0x40-0x7f地址的数据也同样是覆盖整个cache。</li><li>0x00、0x40、0x80地址中index部分是一样的。因此，这3个地址对应的cache line是同一个。</li><li>所以，当我们访问0x00地址时，cache会缺失，然后数据会从主存中加载到cache中第0行cache line。</li><li>当我们访问0x40地址时，依然索引到cache中第0行cache line，由于此时cache line中存储的是地址0x00地址对应的数据，所以此时依然会cache缺失。然后从主存中加载0x40地址数据到第一行cache line中。</li><li>同理，继续访问0x80地址，依然会cache缺失。</li><li>这就相当于每次访问数据都要从主存中读取，所以cache的存在并没有对性能有什么提升。访问0x40地址时，就会把0x00地址缓存的数据替换。</li><li>这种现象叫做<strong>cache颠簸（cache thrashing）</strong>。针对这个问题，我们引入<strong>多路组相连缓存</strong>。我们首先研究下最简单的两路组相连缓存的工作原理。</li></ul><h2 id="两路组相连缓存-Two-way-set-associative-cache"><a href="#两路组相连缓存-Two-way-set-associative-cache" class="headerlink" title="两路组相连缓存(Two-way set associative cache)"></a>两路组相连缓存(Two-way set associative cache)</h2><ul><li><strong>什么是路（way）</strong>：我们依然假设64 Bytes cache size，cache line size是8 Bytes。我们将cache平均分成多份，每一份就是一路。因此，两路组相连缓存就是将cache平均分成2份，每份32 Bytes。如下图所示。</li></ul><p><img src="两路组相连缓存.png" alt="两路组相连缓存" style="zoom:100%;"></p><ul><li>cache被分成2路，每路包含4行cache line。<strong>我们将所有索引一样的cache line组合在一起称之为组</strong>。例如，上图中一个组有两个cache line，总共4个组。</li><li>我们依然假设从地址0x0654地址读取一个字节数据。由于cache line size是8 Bytes，因此offset需要3 bits，这和之前直接映射缓存一样。不一样的地方是index，在两路组相连缓存中，index只需要2 bits，因为一路只有4行cache line。</li><li>上面的例子根据index找到第2行cache line（从0开始计算），第2行对应2个cache line，分别对应way 0和way 1。因此index也可以称作 <code>set index（组索引）</code> 。</li><li>先根据index找到set，然后将组内的所有cache line对应的tag取出来和地址中的tag部分对比，如果其中一个相等就意味着命中。</li><li>因此，两路组相连缓存较直接映射缓存最大的差异就是：第一个地址对应的数据可以对应2个cache line，而直接映射缓存一个地址只对应一个cache line。那么这究竟有什么好处呢？</li></ul><h2 id="两路组相连缓存优缺点"><a href="#两路组相连缓存优缺点" class="headerlink" title="两路组相连缓存优缺点"></a>两路组相连缓存优缺点</h2><ul><li><strong>两路组相连缓存的硬件成本相对于直接映射缓存更高</strong>。因为其每次比较tag的时候需要比较多个cache line对应的tag（某些硬件可能还会做并行比较，增加比较速度，这就增加了硬件设计复杂度）。</li><li>为什么我们还需要两路组相连缓存呢？<strong>因为其可以有助于降低cache颠簸可能性</strong>。那么是如何降低的呢？根据两路组相连缓存的工作方式，我们可以画出主存地址0x00-0x4f地址对应的cache分布图。</li></ul><p><img src="降低cache颠簸.png" alt="降低cache颠簸" style="zoom:100%;"></p><ul><li>我们依然考虑直接映射缓存一节的问题：如果一个程序试图依次访问地址0x00、0x40、0x80，cache中的数据会发生什么呢？。现在0x00地址的数据可以被加载到way 1，0x40可以被加载到way 0。这样是不是就在一定程度上避免了直接映射缓存的尴尬境地呢？在两路组相连缓存的情况下，0x00和0x40地址的数据都缓存在cache中。试想一下，如果我们是4路组相连缓存，后面继续访问0x80，也可能被缓存。</li><li>因此，当cache size一定的情况下，组相连缓存对性能的提升最差情况下也和直接映射缓存一样，在大部分情况下组相连缓存效果比直接映射缓存好。</li><li>同时，其降低了cache颠簸的频率。从某种程度上来说，直接映射缓存是组相连缓存的一种特殊情况，每个组只有一个cache line而已。因此，<strong>直接映射缓存也可以称作单路组相连缓存</strong>。</li></ul><h2 id="全相连缓存-Full-associative-cache"><a href="#全相连缓存-Full-associative-cache" class="headerlink" title="全相连缓存(Full associative cache)"></a>全相连缓存(Full associative cache)</h2><ul><li>既然组相连缓存那么好，如果所有的cache line都在一个组内。岂不是性能更好。是的，这种缓存就是全相连缓存。我们依然以64 Byts大小cache为例说明。</li></ul><p><img src="全相连缓存.png" alt="全相连缓存" style="zoom:100%;"></p><ul><li>由于所有的cache line都在一个组内，因此地址中不需要set index部分。因为，只有一个组让你选择，间接来说就是你没得选。</li><li>我们根据地址中的tag部分和所有的cache line对应的tag进行比较（硬件上可能并行比较也可能串行比较）。哪个tag比较相等，就意味着命中某个cache line。</li><li>因此，在全相连缓存中，任意地址的数据可以缓存在任意的cache line中。</li><li><strong>这可以最大程度的降低cache颠簸的频率。但是硬件成本上也是更高</strong>。</li></ul><h2 id="一个四路组相连缓存实例问题"><a href="#一个四路组相连缓存实例问题" class="headerlink" title="一个四路组相连缓存实例问题"></a>一个四路组相连缓存实例问题</h2><ul><li>考虑这么一个问题，32 KB大小4路组相连cache，cache line大小是32 Bytes。请思考以下2个问题：<ol><li>多少个组？</li><li>假设地址宽度是48 bits，index、offset以及tag分别占用几个bit？</li></ol></li><li>答：总共4路，因此每路大小是8 KB。cache line size是32 Bytes，因此一共有256组（8 KB / 32 Bytes）。由于cache line size是32 Bytes，所以offset需要5位。一共256组，所以index需要8位，剩下的就是tag部分，占用35位。这个cache可以绘制下图表示。</li></ul><p><img src="四路组相连缓存.png" alt="四路组相连缓存" style="zoom:100%;"></p><h2 id="Cache分配策略-Cache-allocation-policy"><a href="#Cache分配策略-Cache-allocation-policy" class="headerlink" title="Cache分配策略(Cache allocation policy)"></a>Cache分配策略(Cache allocation policy)</h2><ul><li>cache的分配策略是指<strong>我们什么情况下应该为数据分配cache line</strong>。cache分配策略分为<code>读</code>和<code>写</code>两种情况。</li></ul><h3 id="读分配-read-allocation"><a href="#读分配-read-allocation" class="headerlink" title="读分配(read allocation)"></a>读分配(read allocation)</h3><ul><li>当CPU读数据时，发生cache缺失，这种情况下都会分配一个cache line缓存从主存读取的数据。默认情况下，cache都支持读分配。</li></ul><h3 id="写分配-write-allocation"><a href="#写分配-write-allocation" class="headerlink" title="写分配(write allocation)"></a>写分配(write allocation)</h3><ul><li>当CPU写数据发生cache缺失时，才会考虑写分配策略。</li><li>当我们不支持写分配的情况下，写指令只会更新主存数据，然后就结束了。</li><li>当支持写分配的时候，我们首先从主存中加载数据到cache line中（相当于先做个读分配动作），然后会<strong>更新</strong>cache line中的数据。</li></ul><h2 id="Cache更新策略-Cache-update-policy"><a href="#Cache更新策略-Cache-update-policy" class="headerlink" title="Cache更新策略(Cache update policy)"></a>Cache更新策略(Cache update policy)</h2><ul><li>cache更新策略是指<strong>当发生cache命中时，写操作应该如何更新数据</strong>。cache更新策略分成两种：<code>写直通</code>和<code>回写</code>。</li></ul><h3 id="写直通-write-through"><a href="#写直通-write-through" class="headerlink" title="写直通(write through)"></a>写直通(write through)</h3><ul><li>当CPU执行store指令并在cache命中时，我们更新cache中的数据并且更新主存中的数据。<strong>cache和主存的数据始终保持一致</strong>。</li></ul><h3 id="写回-write-back"><a href="#写回-write-back" class="headerlink" title="写回(write back)"></a>写回(write back)</h3><ul><li>当CPU执行store指令并在cache命中时，我们只更新cache中的数据。并且每个cache line中会有一个bit位记录数据是否被修改过，称之为dirty bit（翻翻前面的图片，cache line旁边有一个D就是dirty bit）。我们会将dirty bit置位。主存中的数据只会在<strong>cache line被替换</strong>或者<strong>显式的clean操作</strong>时更新。</li><li>因此，主存中的数据可能是未修改的数据，而修改的数据躺在cache中。<strong>cache和主存的数据可能不一致</strong>。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>假设我们有一个64 Bytes大小直接映射缓存，cache line大小是8 Bytes，采用写分配和写回机制。当CPU从地址0x2a读取一个字节，cache中的数据将会如何变化呢？</li><li>假设当前cache状态如下图所示(tag旁边valid一栏的数字1代表合法。0代表非法。后面Dirty的1代表dirty，0代表没有写过数据，即非dirty)。</li></ul><p><img src="Cache读写.png" alt="Cache读写示例" style="zoom:100%;"></p><ul><li>根据index找到对应的cache line，对应的tag部分valid bit是合法的，但是tag的值不相等，因此发生缺失。</li><li>此时我们需要从地址0x28地址（请注意cache line大小对齐）加载8字节数据到该cache line中。但是，我们发现当前cache line的dirty bit置位。</li><li>因此，cache line里面的数据不能被简单的丢弃，由于采用写回机制，所以我们需要将cache中的数据0x11223344写到地址0x0128地址（这个地址根据tag中的值及所处的cache line行计算得到）。这个过程如下图所示。</li></ul><p><img src="Cache读写(2).png" alt="Cache读写示例" style="zoom:100%;"></p><ul><li>当写回操作完成，我们将主存中0x28地址开始的8个字节加载到该cache line中，并清除dirty bit。然后根据offset找到0x52返回给CPU。</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li>我们一直避开了一个关键问题。我们都知道cache控制器根据地址查找判断是否命中，这里的地址究竟是虚拟地址(virtual address，VA)还是物理地址(physical address，PA)？</li><li>详情参考下一篇博客 <a href="/Eight-Part_Essay/Computer_Organization/Cache_Organization_Method/">Cache组织方式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache的组织方式</title>
      <link href="//Eight-Part_Essay/Computer_Organization/Cache_Organization_Method/"/>
      <url>//Eight-Part_Essay/Computer_Organization/Cache_Organization_Method/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 八股文 - 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎玉零珠————计算机组成原理</title>
      <link href="/2025/07/20/Eight-Part_Essay/Computer_Organization/Broken_Jade_Beads/BrokenJadeBeads/"/>
      <url>/2025/07/20/Eight-Part_Essay/Computer_Organization/Broken_Jade_Beads/BrokenJadeBeads/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是缓存-Cache-？为什么需要缓存？如何提高缓存的命中率？缓存是不是最快的？"><a href="#什么是缓存-Cache-？为什么需要缓存？如何提高缓存的命中率？缓存是不是最快的？" class="headerlink" title="什么是缓存(Cache)？为什么需要缓存？如何提高缓存的命中率？缓存是不是最快的？"></a>什么是缓存(Cache)？为什么需要缓存？如何提高缓存的命中率？缓存是不是最快的？</h2><ul><li>Cache即CPU的高速缓冲存储器，是一种是用于减少处理器访问内存所需平均时间的部件；</li><li>由于CPU的计算速度远远大于从CPU向内存取数据的速度，如果每次都让CPU去内存取数据，会导致CPU计算能力的浪费，所以人们设计了缓存，CPU通过读写缓存来获取操作数，结果也通过缓存写入内存；</li><li>注意程序的<strong>局部性原理</strong>，在遍历数组时按照内存顺序访问；充分利用<strong>CPU分支预测功能</strong>，将预测的指令放到缓存中执行；此外缓存的容量和块长是影响缓存效率的重要因素。</li><li>缓存不是最快的，寄存器更快。</li><li>附 <a href="/Eight-Part_Essay/Computer_Organization/The_Basic_Principle_Of_Cache/">Cache 的基本原理</a></li></ul><h2 id="编译器、汇编器和链接器的基本概念"><a href="#编译器、汇编器和链接器的基本概念" class="headerlink" title="编译器、汇编器和链接器的基本概念"></a>编译器、汇编器和链接器的基本概念</h2><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><ul><li>编译器把高级语言翻译为机器语言</li><li>得到 <code>hello.s</code> 文件，这个是汇编语言程序</li><li>不同的高级语言翻译的汇编语言相同</li></ul><h3 id="汇编器"><a href="#汇编器" class="headerlink" title="汇编器"></a>汇编器</h3><ul><li>汇编器将 <code>hello.s</code> 翻译成机器语言指令，把这些指令打包成可重定位目标程序。</li><li>得到 <code>.o</code> 文件，是一个二进制文件，它的字节码是机器语言指令，不再是字符。前面两个阶段都还有字符。</li></ul><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><ul><li>链接器负责 <code>.o</code> 文件的合并。得到的是可执行目标文件。</li><li>gcc会到系统默认的搜索路径 <code>/usr/lib</code>下进行查找，也就是链接到 <code>libc.so.6</code> 库函数中去。 函数库一般分为静态库和动态库两种。</li><li>静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为 <code>.a</code>。</li><li>动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。动态库一般后缀名为 <code>.so</code>，如前面所述的 <code>libc.so.6</code> 就是动态库。gcc在编译时默认使用动态库。</li></ul><h2 id="编译过程的五个阶段"><a href="#编译过程的五个阶段" class="headerlink" title="编译过程的五个阶段"></a>编译过程的五个阶段</h2><ul><li><strong>第一阶段：词法分析</strong><ol><li>词法分析的任务是：<strong>输入源程序，对构成源程序的字符串进行扫描和分解，识别出一个个的单词（亦称单词符号或简称符号）</strong>。如基本字（begin、end、if、for、while），标识符、常数、运算符和界符（标点符号、左右括号）。</li><li>在词法分析阶段的工作中所依循的是语言的词法规则（或称构词规则）。描述词法规则的有效工具是正规式和有效自动机。</li></ol></li><li><strong>第二阶段：语法分析</strong><ol><li>语法分析的任务是：<strong>在词法分析的基础上，根据语言的语法规则，把单词符号串分解成各类语法单位（语法范畴）</strong>。如“短语”、“句子”、“程序段”和“程序”等。</li><li>通过语法分析，确定整个输入串是否构成语法上正确的“程序”。语法分析所依循的是语言的语法规则。</li><li>词法分析是一种线性分析，而语法分析是一种层次结构分析。例如：Z = X + 0.618 · Y;代表一个“赋值语句”，而其中的X + 0.618 · Y 代表一个“算术表达式”。因而，语法分析的任务就是识别X + 0.618 · Y为算术表达式。同时，上述整个符号串乘以十属于赋值语句这个范畴。</li></ol></li><li><strong>第三阶段:词义分析与中间代码产生</strong><ol><li>这一阶段的任务是：<strong>对语法分析所识别出的各类语法范畴，分析其含义，并进行初步翻译（产生中间代码）</strong>。</li><li>这一阶段通常包含两个方面的工作。首先，对每种语法范畴进行语义i安插，例如，变量是否定义、类型是否正确等等。如果语义正确，则进行另一方面工作，即进行中间代码的解释。</li></ol></li><li><strong>第四阶段：优化</strong><ol><li>优化的任务是：<strong>对前段产生的中间代码进行加工变换，以便在最后阶段能产生出更为高效（省时间和空间）的目标代码</strong>。</li><li>优化的主要方面有：公关子表达式的提取、循环优化、删除无用代码等等。有时，为了便于“并行运算”，还可以对代码进行并行化处理。</li><li>优化所依循的原则是程序的等价变换规则。</li></ol></li><li><strong>第五阶段：目标代码生成</strong><ol><li>这一阶段的任务是：<strong>把中间代码（或经优化处理之后）变换成特定机器上的低级语言代码</strong>。</li><li>这阶段实现了最后的翻译，它的工作有赖于硬件系统结构和机器指令含义。</li><li>这阶段工作非常复杂，设计到硬件系统功能部件的运用，机器指令的选择，各种数据类型变量的存储空间分配，以及寄存器和后援寄存器的调度，等等。</li><li>目标代码的形式可以是绝对指令代码或可重定位的指令代码或汇编指令代码。如目标代码是绝对指令代码，则这种目标代码可立即执行。如果目标代码是汇编指令代码，则需汇编器汇编之后才行运行。</li><li>必须指出，现在多数实用编译程序所产生的目标代码都是一种可重定位的指令代码。这种目标代码在运行前必须借助于一个连接装配程序把各个目标模块（包括系统提供的库函数）连接在一起，确定程序变量（或常数）在主存中的位置，装入内存中指定的起始地址，使之成为一个可以运行的绝对指令代码程序。</li></ol></li></ul><h2 id="CPU由什么构成的"><a href="#CPU由什么构成的" class="headerlink" title="CPU由什么构成的"></a>CPU由什么构成的</h2><ul><li>CPU内部主要由 <code>运算器</code> 、<code>控制器</code> 、<code>寄存器</code> 三大部分组成。<ol><li><strong>运算器</strong>：负责算术运算（+ - * / 基本运算和附加运算）和逻辑运算（包括 移位、逻辑测试或比较两个值等）。</li><li><strong>控制器</strong> 负责应对所有的信息情况，调度运算器把计算做好。</li><li><strong>寄存器</strong> 它们可用来暂存指令、数据和地址。既要对接控制器的命令，传达命令给运算器；还要帮运算器记录处理完或者将要处理的数据。</li></ol></li></ul><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><ol><li>正数的补码保持原码不变（反码也是）：3 = { 0_0000011 }</li><li>负数的补码先求反码，然后再加 1 ：-5 = [ 1_1111010 ] + 1 = { 1_1111011 }</li></ol><ul><li>于是 3 + { -5 } = { -2 } 的计算过程为：</li><li>{ 0_0000011 } + { 1_1111011 } = { 11111110 }</li><li>至此，通过补码就成功解决了数字 0 在计算机中非唯一编码的问题，且也能实现减法变加法。</li></ul><h2 id="寄存器有哪几种类型（主要）"><a href="#寄存器有哪几种类型（主要）" class="headerlink" title="寄存器有哪几种类型（主要）"></a>寄存器有哪几种类型（主要）</h2><ul><li>数据寄存器</li><li>指令寄存器</li><li>程序寄存器</li><li>地址寄存器</li><li>累加寄存器</li><li>程序状态字寄存器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程、线程、协程之间的区别</title>
      <link href="/2025/07/20/Eight-Part_Essay/Computer_Operating_System/Process_Thread_Coroutine/PTC/"/>
      <url>/2025/07/20/Eight-Part_Essay/Computer_Operating_System/Process_Thread_Coroutine/PTC/</url>
      
        <content type="html"><![CDATA[<h2 id="简述进程、线程、协程的概念"><a href="#简述进程、线程、协程的概念" class="headerlink" title="简述进程、线程、协程的概念"></a>简述进程、线程、协程的概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，不同进程间可以进行进程间通信，上级挂靠单位是操作系统。一个应用程序相当于一个进程，操作系统会以进程为单位，分配系统资源（CPU 时间片、内存等资源），进程是资源分配的最小单位。</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li><p>线程从属于进程，也被称为轻量级进程，是程序的实际执行者。线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条- 线程并行执行不同的任务。一个线程只有一个进程。</p></li><li><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p></li><li><p>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。</p></li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li><p>协程是伴随着主线程一起运行的一段程序。</p></li><li><p>协程与协程之间是并行执行，与主线程也是并行执行，同一时间只能执行一个协程提起协程，自然是要想到线程，因为协程的定义就是伴随主线程来运行的。</p></li><li><p>一个线程可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程序所控制。</p></li><li><p>协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。</p></li><li><p>协成是单线程下由应用程序级别实现的并发。</p></li></ul><h2 id="简述协程的作用"><a href="#简述协程的作用" class="headerlink" title="简述协程的作用"></a>简述协程的作用</h2><ul><li><p>在Unity中只有主线程才能访问Unity3D的对象、方法、组件。当主线程在执行一个对资源消耗很大的操作时，在这一帧我们的程序就会出现帧率下降，画面卡顿的现象!</p></li><li><p>那这个时候我们就可以利用协程来做这件事，因为协程是伴随着主线程运行的，主线程依旧可以丝滑轻松的工作，把脏活累活交给协程处理就好了！简单来说：协程是辅助主线程的操作，避免游戏卡顿。</p></li></ul><h2 id="简述协程的底层原理"><a href="#简述协程的底层原理" class="headerlink" title="简述协程的底层原理"></a>简述协程的底层原理</h2><ul><li><p>协程是通过迭代器来实现功能的，通过关键字IEnumerator来定义一个迭代方法。</p></li><li><p>StartCoroutine 接受到的是一个 IEnumerator ，这是个接口，并且是枚举器或迭代器的意思。</p></li><li><p>yield 是 C#的一个关键字，也是一个语法糖，背后的原理会生成一个类，并且也是一个枚举器，而且不同于 return，yield 可以出现多次。</p></li><li><p>yield 实际上就是返回一次结果，因为我们要一次一次枚举一个值出来，所以多个 yield 其实是个状态模式，第一个 yield 是状态 1，第二个 yield 是状态 2，每次访问时会基于状态知道当前应该执行哪一个 yield，取得哪一个值。</p></li></ul><blockquote><p>从程序的角度讲，协程的核心就是迭代器。 想要定义一个协程方法有两个因素:<br>第一: 方法的返回值为 IEnumerator 。<br>第二: 方法中有 yield 关键字。 当代码满足以上两个条件时，此方法的执行就具有了迭代器的特质，其核心就是 MoveNext方法。</p><p>方法内的内容将会被分成两部分：yield 之前的代码和 yield 之后的代码。<br>yield之前的代码会在第一次执行MoveNext时执行， yield之后的代码会在第二次执行MoveNext方法时执行。</p><p>而在Unity中，MoveNext 的执行时机是以帧为单位的，无论你是设置了延迟时间，还是通过按钮调用 MoveNext ，亦或是根本没有设置执行条件，Unity都会在每一帧的生命周期中判断当前帧是否满足当前协程所定义的条件，一旦满足，当前帧就会抽出CPU时间执行你所定义的协程迭代器的 MoveNext 。</p><p>注意，只要方法中有 yield 语句，那么方法的返回值就必须是 IEnumerator ，不然无法通过编译。</p></blockquote><h2 id="线程与协程的区别"><a href="#线程与协程的区别" class="headerlink" title="线程与协程的区别"></a>线程与协程的区别</h2><ul><li><p>协程：即协作式程序，其思想是，一系列互相依赖的协程间依次使用CPU，每次只有一个协程工作，而其他协程处于休眠状态。协程实际上是在一个线程中，只不过每个协程对CPU进行分时，协程可以访问和使用unity的所有方法和component。同一时间只能执行某个协程。开辟多个协程开销不大。协程适合对某任务进行分时处理。</p></li><li><p>线程：多线程是阻塞式的，每个IO都必须开启一个新的线程，但是对于多CPU的系统应该使用thread，尤其是有大量数据运算的时刻，但是IO密集型就不适合；而且thread中不能操作unity的很多方法和component。同一时间可以同时执行多个线程。开辟多条线程开销很大。线程适合多任务同时处理。</p></li><li><p>线程和协同程序的主要不同在于：在多处理器情况下，从概念上来讲多线程程序同时运行多个线程；而协同程序是通过协作来完成，在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只在必要时才会被挂起。</p></li></ul><h2 id="协同程序-有何用处-有何缺点"><a href="#协同程序-有何用处-有何缺点" class="headerlink" title="协同程序 有何用处? 有何缺点?"></a>协同程序 有何用处? 有何缺点?</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>一个协同程序在执行过程中,可以在任意位置使用 yield 语句。</li><li>yield 的返回值控制何时恢复协同程序向下执行。</li><li>协同程序在对象自有帧执行过程中堪称优秀。</li><li>协同程序在性能上没有更多的开销。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>协同程序并非真线程，可能会发生堵塞。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程调度算法</title>
      <link href="/2025/07/20/Eight-Part_Essay/Computer_Operating_System/Process_Scheduling/ProcessScheduling/"/>
      <url>/2025/07/20/Eight-Part_Essay/Computer_Operating_System/Process_Scheduling/ProcessScheduling/</url>
      
        <content type="html"><![CDATA[<h2 id="进程的调度方式"><a href="#进程的调度方式" class="headerlink" title="进程的调度方式"></a>进程的调度方式</h2><ul><li><p>通常有以下两种进程调度方式：</p><ol><li><strong>非剥夺（非抢占）调度方式</strong>：当一个进程正在处理机上执行时，即使有某个更为重要或者紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞态时，才把处理机分配给更为重要或紧迫（优先级更高）的进程。其优点是实现简单，系统开销小，适用于大多数批处理系统，但它不能用于分时系统和大多数实时系统。</li><li><strong>剥夺（抢占）调度方式</strong>：当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程（优先级更高）的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更重要的进程。这种方式对提高系统吞吐率和响应效率都有明显的好处。但抢占也要遵循一定原则。</li></ol></li></ul><h2 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h2><ul><li>主要有以下几种：<ol><li><strong>CPU利用率</strong>：CPU是计算机系统中最重要和最昂贵的资源之一，所以应该尽可能使得CPU保持忙的状态，资源利用率尽可能高。</li><li><strong>系统吞吐量</strong>：单位时间内CPU完成的作业数量。长作业需要消耗较长的处理机时间，会降低系统的吞吐量。对于短作业，他们所需消耗的处理机时间较短，因此能提高系统吞吐量。调度算法和方式不同，也会对系统的吞吐量产生较大影响。</li><li><strong>周转时间</strong>：周转时间是指<strong>从作业提交到作业完成所经历的时间</strong>，是作业等待、在就绪队列中排队，在处理机上运行及输入输出操作所花费的时间的总和。</li><li><strong>等待时间</strong>：进程处于等处理机状态的时间之和。等待时间越长，用户满意度越低。实际上，处理机调度算法实际上并不影响作业执行或输入输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，<strong>衡量一个调度算法的优劣，常常只需简单地考察等待时间</strong>。</li><li><strong>响应时间</strong>：用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般采用响应时间作业衡量调度算法的重要准则之一。从用户角度来看，调度策略应该尽量降低响应时间，使得响应时间处在用户能接受的范围之内。</li></ol></li><li>总之，想得到一个满足所有用户和系统要求的算法几乎是不可能的。设计调度程序，一方面要满足特定系统用户的要求（比如，实时和交互进程的快速响应要求），另一方面要考虑系统整体的效率（比如，减少整个系统的进程平均周转时间），同时还要考虑调度算法的开销等。</li></ul><h2 id="几种典型的调度算法"><a href="#几种典型的调度算法" class="headerlink" title="几种典型的调度算法"></a>几种典型的调度算法</h2><ul><li><strong>先来先服务（FCFS）调度算法</strong></li><li><strong>短作业优先（SJF）调度算法</strong></li><li><strong>优先级调度算法</strong></li><li><strong>高响应比优先调度算法</strong><ul><li>在每次进行作业调度时，先计算后备队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</li><li>响应比 = (等待时间+要求服务时间) / 要求服务时间</li><li>根据公式可知：<ol><li>作业的等待时间相同时，要求服务时间约旦，响应比越高，有利于短作业。</li><li>要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。</li><li>对于长作业，作业的响应比可以随等待时间的增加而提高，等待时间足够长时，其响应比便可升到很高，从而可以获得处理机，不会饿死。</li></ol></li></ul></li><li><strong>时间片轮转调度算法</strong><ol><li>时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序<strong>总是选择就绪队列中的第一个进程执行，即先来先服务的原则，但是仅能运行一个时间片</strong>。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被抢占）处理机给下一个就绪的进程，而被抢占的进程返回到就绪队列的末尾重新排队，等候再次运行。</li><li>在时间片轮转的调度算法中，时间片的大小对系统性能有很大影响。如果<strong>时间片足够大</strong>，以至于所以进程都能在一个事件内执行完毕，则时间片轮转调度算法就<strong>退化成FCFS算法</strong>。如果<strong>时间片很小</strong>，则处理机将在进程间过于频繁地切换，使得<strong>处理机开销增大</strong>，而真正用于运行用户进程的时间将减少。因此，时间片的选择要适当，可以根据系统响应时间、就绪队列中的进程数目和系统的处理能力等决定。</li></ol></li><li><strong>多级反馈队列调度算法</strong><ol><li>设置多个就绪队列，并为各个队列赋予不同的优先级，第一级队列的优先级最高，第二级队列次之，其余队列的优先级逐次降低。</li><li>赋予各个队列中进程执行时间片的大小各不相同。在优先级越高的队列中，每个进程的运行时间片越小。例如，第二级队列的时间片要比第一级队列的时间片长一倍…第i+1级队列的时间片要比第i级队列的时间片长一倍。</li><li>当一个新的进程进入内存后，首先将它放入第一级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时候，如果它能在时间片内完成，便可准备撤离系统；若它在一个时间片结束时尚未完成，调度程序便将该进程转入第二级末尾，再同样按FCFS原则等待调度执行；若它在第二级队列中运行一个时间片后仍未完成，再以同样的方法进入第三级队列…如此下去，当一个长进程从第一级队列一次降到第n级队列后，在第n级队列中便采用时间片轮转方式进行。</li><li>仅当第一级队列为空时，调度程序才调度第二级队列中的进程进行；仅当第1到（i-1）级队列均为空，才会调度第i级队列中的进程运行。若处理机正在执行第i级队列中的某个进程，此时又有新的进程进入优先级较高的队列（第1到（i-1）级的任意一级），则此时行进程将抢占正在运行的处理机，即由调度程序把正在运行的进程放回第i级队列末尾，把处理机分配给新到的更高优先级进程。</li></ol><ul><li>这种调度方法优势如下：<ol><li>终端型作业用户：短作业优先。</li><li>短批处理作业用户：周转时间较短。</li><li>长批处理作业用户：经过前面几个队列得到部分执行，不会饿死。<br><img src="多级反馈队列.png" alt="多级反馈队列算法" style="zoom:100%;"></li></ol></li></ul></li></ul><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul><li>根据下表给出的进程调度信息，描述分别采用FCFS、非抢占式SJF、抢占式SJF调度算法、非抢占式优先权、抢占式优先权及时间片轮转（时间片为1）算法的执行次序，并计算平均周转时间和平均等待时间。（注：优先数越大，优先级越小）</li></ul><div class="table-container"><table><thead><tr><th>进程</th><th>到达时刻（秒）</th><th>执行时间（秒）</th><th>优先级</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>10</td><td>3</td></tr><tr><td>P2</td><td>2</td><td>1</td><td>1</td></tr><tr><td>P3</td><td>4</td><td>2</td><td>3</td></tr><tr><td>P4</td><td>5</td><td>1</td><td>4</td></tr><tr><td>P5</td><td>6</td><td>5</td><td>2</td></tr></tbody></table></div><ul><li>解答：</li></ul><p><img src="进程调度.png" alt="进程调度题解" style="zoom:100%;"></p><ul><li>平均周转时间和平均等待时间的求解:</li></ul><div class="table-container"><table><thead><tr><th>进程</th><th>FCFS周期时间</th><th>抢占式SJF周转时间</th><th>非抢占式SJF周转时间</th><th>非抢占式优先级周转时间</th><th>抢占式优先级周转时间</th><th>时间片轮转周转时间</th></tr></thead><tbody><tr><td>P1</td><td>10s</td><td>19s</td><td>10s</td><td>10s</td><td>16s</td><td>19s</td></tr><tr><td>P2</td><td>9s</td><td>1s</td><td>9s</td><td>9s</td><td>1s</td><td>1s</td></tr><tr><td>P3</td><td>9s</td><td>3s</td><td>10s</td><td>14s</td><td>14s</td><td>4s</td></tr><tr><td>P4</td><td>9s</td><td>1s</td><td>7s</td><td>14s</td><td>14s</td><td>2s</td></tr><tr><td>P5</td><td>13s</td><td>6s</td><td>13s</td><td>10s</td><td>5s</td><td>11s</td></tr><tr><td>平均周转时间</td><td>8s</td><td>6s</td><td>9.8s</td><td>11.4s</td><td>10s</td><td>7.4s</td></tr></tbody></table></div><ul><li>提示：用进程到达（提交）的时间减去最终进程完成的时间即可。</li></ul><div class="table-container"><table><thead><tr><th>进程</th><th>FCFS周期时间</th><th>抢占式SJF周转时间</th><th>非抢占式SJF周转时间</th><th>非抢占式优先级周转时间</th><th>抢占式优先级周转时间</th><th>时间片轮转周转时间</th></tr></thead><tbody><tr><td>P1</td><td>10s</td><td>19s</td><td>10s</td><td>10s</td><td>16s</td><td>19s</td></tr><tr><td>P2</td><td>9s</td><td>1s</td><td>9s</td><td>9s</td><td>1s</td><td>1s</td></tr><tr><td>P3</td><td>9s</td><td>3s</td><td>10s</td><td>14s</td><td>14s</td><td>4s</td></tr><tr><td>P4</td><td>9s</td><td>1s</td><td>7s</td><td>14s</td><td>14s</td><td>2s</td></tr><tr><td>P5</td><td>13s</td><td>6s</td><td>13s</td><td>10s</td><td>5s</td><td>11s</td></tr><tr><td>平均周转时间</td><td>8s</td><td>6s</td><td>9.8s</td><td>11.4s</td><td>10s</td><td>7.4s</td></tr></tbody></table></div><ul><li>提示：进程到达（提交）后，只要没有执行完并且没有分配处理机，就是在等待状态。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程内存分布</title>
      <link href="/2025/07/20/Eight-Part_Essay/Computer_Operating_System/Process_Memory_Distribution/ProcessMemoryDistribution/"/>
      <url>/2025/07/20/Eight-Part_Essay/Computer_Operating_System/Process_Memory_Distribution/ProcessMemoryDistribution/</url>
      
        <content type="html"><![CDATA[<h2 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h2><ul><li>以32位系统为例，共有4G的寻址能力，进程在内存中的分布如下图所示。Linux默认将高地址的1G空间分配给内核，称为内核空间，剩下的3G空间分配给进程使用，称为用户空间。</li></ul><div class="table-container"><table><thead><tr><th>操作系统内核区</th><th>用户不可见</th></tr></thead><tbody><tr><td>用户栈</td><td>栈指针，向下扩展</td></tr><tr><td>动态堆</td><td>向上扩展</td></tr><tr><td>全局区（静态区）</td><td>.data初始化 .bss未初始化</td></tr><tr><td>文字常量区（只读数据）</td><td>常量字符串</td></tr><tr><td>程序代码区</td><td>栈指针，向下扩展</td></tr></tbody></table></div><p><img src="进程内存分布.png" alt="进程内存分布" style="zoom:100%;"></p><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><ul><li>由编译器自动分配释放，速度较快</li><li>用来存储函数调用时的临时信息的结构，存放为运行时函数分配的<strong>局部变量</strong>、<strong>函数参数</strong>、<strong>返回数据</strong>、<strong>返回地址</strong>等。这些局部变量等空间都会被释放</li><li>程序运行过程中函数调用时参数的传递也在栈上进行，如递归调用栈</li><li>当栈过多的时候，就是导致栈溢出（比如大量的递归调用或者大量的内存分配）</li><li>栈是向低地址扩展的数据结构，是一块连续的内存的区域，空间有限</li></ul><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><ul><li>由程序员分配 (new,malloc) 释放 (delete,free) ，并指明大小，速度较慢</li><li>若程序员不释放，导致内存泄漏，new 完没有 delete</li><li>不过在整个程序结束时由操作系统回收,但是这样无疑增加了操作系统的负担</li><li>高地址扩展的数据结构，是不连续的内存区域，空间很大，比较灵活</li><li>频繁地分配和释放不同大小的堆空间容易产生内存碎片</li></ul><p><strong>注：当 堆区 数据地址 和 栈区 数据地址相同时（碰面了）就代表，数据已用完。</strong></p><h3 id="全局区（静态区static）"><a href="#全局区（静态区static）" class="headerlink" title="全局区（静态区static）"></a>全局区（静态区static）</h3><ul><li>全局变量和静态变量是放在一起的</li><li>初始化的全局变量和静态变量（static修饰的）放在一块区域.data节</li><li>未初始化的全局变量和未初始化的静态变量在相邻的另一块区域.bss（不占磁盘空间，不做具体解释）</li><li>程序结束后由系统释放</li></ul><h3 id="文字常量区"><a href="#文字常量区" class="headerlink" title="文字常量区"></a>文字常量区</h3><ul><li>常量字符串就是放在这里，程序结束后由系统释放</li></ul><h3 id="程序代码区"><a href="#程序代码区" class="headerlink" title="程序代码区"></a>程序代码区</h3><ul><li>存放函数体的二进制代码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面置换算法</title>
      <link href="/2025/07/20/Eight-Part_Essay/Computer_Operating_System/Page_Replacement/PageReplacement/"/>
      <url>/2025/07/20/Eight-Part_Essay/Computer_Operating_System/Page_Replacement/PageReplacement/</url>
      
        <content type="html"><![CDATA[<h2 id="页面置换算法简介"><a href="#页面置换算法简介" class="headerlink" title="页面置换算法简介"></a>页面置换算法简介</h2><ul><li>进程运行时，若其访问的页面不在内存而需将其调入（<strong>缺页异常</strong>），但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区，其中选择调出页面的算法就称为页面置换算法。</li><li>好的页面置换算法应有<strong>较低的页面更换频率</strong>，也就是说，应将以后不会再访问或者以后较长时间内不会再访问的页面先调出。</li><li>页面置换算法的目标是<strong>最小化缺页中断的次数</strong>，常见的页面置换算法有<code>最佳⻚⾯置换算法（OPT）</code>、<code>先进先出置换算法（FIFO）</code>、<code>最近最久未使⽤的置换算法（LRU）</code>、<code>时钟页面置换算法</code>和<code>最不常⽤置换算法</code>等。</li></ul><h2 id="最佳页面置换算法（淘汰未来不会使用-最长时间不访问的页面）"><a href="#最佳页面置换算法（淘汰未来不会使用-最长时间不访问的页面）" class="headerlink" title="最佳页面置换算法（淘汰未来不会使用/最长时间不访问的页面）"></a>最佳页面置换算法（淘汰未来不会使用/最长时间不访问的页面）</h2><ul><li>理论上的最佳算法，因为它可以保证最低的缺页率。但在实际应用中，由于无法预知未来的访问模式，OPT 通常无法实现。</li></ul><p><img src="最佳页面置换.png" alt="最佳页面置换" style="zoom:100%;"></p><h2 id="先进先出置换算法（优先淘汰最早进入内存的页面）"><a href="#先进先出置换算法（优先淘汰最早进入内存的页面）" class="headerlink" title="先进先出置换算法（优先淘汰最早进入内存的页面）"></a>先进先出置换算法（优先淘汰最早进入内存的页面）</h2><ul><li>FIFO 算法维护一个队列，新来的页面加入队尾，当发生页面置换时，队头的页面（即最早进入内存的页面）被移出。</li></ul><p><img src="先进先出置换.png" alt="先进先出置换" style="zoom:100%;"></p><ul><li><strong>FIFO 和 OPT 算法的区别在于：除了在时间上向后或向前看之外，FIFO 算法使用的是页面调入内存的时间，OPT 算法使用的是页面将来使用的时间</strong></li></ul><h2 id="最近最久未使用的置换算法（淘汰最近没有使用的页面）"><a href="#最近最久未使用的置换算法（淘汰最近没有使用的页面）" class="headerlink" title="最近最久未使用的置换算法（淘汰最近没有使用的页面）"></a>最近最久未使用的置换算法（淘汰最近没有使用的页面）</h2><ul><li>LRU 算法根据页面的访问历史（维护一个链表）来进行置换，<strong>最长时间未被访问的页面</strong>将被置换出去。</li><li>相对更接近最优算法的效果，因为最近未使用的页面可能在将来也不会被使用。但 LRU 算法的实现需要跟踪页面的访问历史，可能会增加系统的开销。</li></ul><p><img src="最近最久未使用.png" alt="最近最久未使用" style="zoom:100%;"></p><h2 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h2><ul><li>通过一个类似钟面的（环形链表）遍历页面，每个页面有一个使用位，当页面被访问时，使用位设置为 1。</li><li>当需要页面置换时，时钟指针会顺时针移动，直到找到使用位为 0 的页面进行置换。这个过程类似于给每个页面一个二次机会。算法执行时，会先将使用位从 1 清零，如果该页面再次被访问，它的使用位再次被设置为 1。</li></ul><p><img src="时钟页面置换.png" alt="时钟页面置换" style="zoom:100%;"></p><h2 id="最不常用置换算法"><a href="#最不常用置换算法" class="headerlink" title="最不常用置换算法"></a>最不常用置换算法</h2><ul><li>根据页面被访问的频率进行置换，<strong>访问次数最少的页面最先被置换</strong>。实现较为复杂，需要记录每个页面的访问频率。</li><li>它的实现方式是，对每个页面设置⼀个<strong>访问计数器</strong>，每当⼀个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。</li><li>看起来很简单，每个页面加⼀个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。<ol><li>要增加⼀个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表很长，是非常耗时的，效率不高。</li><li>还有个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。</li></ol></li><li>这个问题的解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎玉零珠————计算机操作系统</title>
      <link href="/2025/07/20/Eight-Part_Essay/Computer_Operating_System/Broken_Jade_Beads/BrokenJadeBeads/"/>
      <url>/2025/07/20/Eight-Part_Essay/Computer_Operating_System/Broken_Jade_Beads/BrokenJadeBeads/</url>
      
        <content type="html"><![CDATA[<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><ul><li><strong>并发</strong>：<strong>在一段时间内</strong>，多个任务都会被处理。<strong>但在某一时刻，只有一个任务在执行</strong>。单核处理器做到的并发，其实是利用时间片的轮转，例如有两个进程 A 和 B，A 运行一个时间片之后，切换到 B，B 运行一个时间片之后又切换到 A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。</li><li><strong>并行</strong>：<strong>在同一时刻</strong>，有多个任务在执行。这个<strong>需要多核处理器才能完成</strong>，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。</li></ul><p><img src="并发与并行.png" alt="并发与并行" style="zoom:100%;"></p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><ul><li><strong>运⾏状态（Runing）</strong>：该时刻进程占用 CPU；</li><li><strong>就绪状态（Ready）</strong>：可运行，由于其他进程处于运行状态而暂时停止运行；</li><li><strong>阻塞状态（Blocked）</strong>：该进程正在等待某⼀事件发生（如等待输⼊/输出操作的完成）而暂时停止运行，这时，即使给它 CPU 控制权，它也无法运行；</li><li><strong>创建状态（new）</strong>：进程正在被创建时的状态；</li><li><strong>结束状态（Exit）</strong>：进程正在从系统中消失时的状态；</li></ul><p><img src="进程的状态.png" alt="进程的状态" style="zoom:100%;"></p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul><li>进程是一个正在执行的程序的实例。<strong>每个进程有自己独立的地址空间、全局变量、堆栈、和文件描述符等资源</strong>。</li><li>线程是进程中的一个执行单元。一个进程可以包含多个线程，<strong>它们共享进程的地址空间和资源</strong>。</li><li>每个进程在独立的地址空间中运行，<strong>不会</strong>直接影响其他进程。线程共享<strong>同一个进程</strong>的内存空间、全局变量和文件描述符。</li><li>进程切换需要保存和恢复大量的上下文信息，代价较高。线程切换相对较轻量，因为线程共享进程的地址空间，只需要保存和恢复线程私有的数据。</li><li>线程的生命周期由进程控制，进程终止时，其所有线程也会终止。</li></ul><div class="table-container"><table><thead><tr><th>特性</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>地址空间</td><td>独立</td><td>共享</td></tr><tr><td>内存开销</td><td>高</td><td>低</td></tr><tr><td>上下文切换</td><td>慢，开销大</td><td>快，开销小</td></tr><tr><td>通信</td><td>需要IPC机制，开销较大</td><td>共享内存，直接通信</td></tr><tr><td>创建销毁</td><td>开销大，较慢</td><td>开销小，较快</td></tr><tr><td>并发性</td><td>低</td><td>高</td></tr><tr><td>崩溃影响</td><td>一个进程崩溃不会影响其他进程</td><td>一个线程崩溃可能导致整个进程崩溃</td></tr></tbody></table></div><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><ul><li>这还得看线程是不是属于同⼀个进程：<ol><li>当两个线程<strong>不属于</strong>同⼀个进程，则切换的过程就跟进程上下文切换⼀样；</li><li>当两个线程<strong>属于</strong>同⼀个进程，因为<strong>虚拟内存是共享的</strong>，所以在切换时，虚拟内存这些资源就保持不动，<strong>只需要切换线程的私有数据、寄存器等不共享的数据</strong>；</li></ol></li><li>所以，线程的上下文切换相比进程，开销要小很多。</li></ul><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><ul><li>允许两个或多个进程共享一个给定的内存区，一个进程写⼊的东西，其他进程⻢上就能看到。</li><li>共享内存是最快的进程间通信方式，它是针对其他进程间通信方式运行效率低而专门设计的。</li><li><strong>缺点</strong>：当多进程竞争同一个共享资源时，会造成数据错乱的问题。</li></ul><p><img src="共享内存.png" alt="共享内存" style="zoom:50%;"></p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><ul><li>我们实际的物理内存主要是主存，但是物理主存空间有限，所以一般现代操作系统都会想办法把一部分内存块放到磁盘中，用到的时候再装入主存，但是对用户程序而言，是不需要注意实际的物理内存的，为什么呢？因为有<code>虚拟内存</code>的机制。</li><li>简单说，<strong>虚拟内存是操作系统提供的⼀种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来</strong>。</li><li>每个进程都有自己独立的地址空间，再由操作系统映射到到实际的物理内存。</li><li>于是，这里就引出了两种地址的概念：<ol><li>程序所使用的内存地址叫做虚拟内存地址（Virtual Memory Address）。</li><li>实际存在硬件里面的空间地址叫物理内存地址（Physical Memory Address）。<br><img src="虚拟内存.png" alt="虚拟内存" style="zoom:50%;"></li></ol></li></ul><h3 id="为什么要使用虚拟内存？"><a href="#为什么要使用虚拟内存？" class="headerlink" title="为什么要使用虚拟内存？"></a>为什么要使用虚拟内存？</h3><ul><li>程序是运行在内存中的，程序运行时会将保存在硬盘上的程复制到RAM内存（载入内存），然后CPU执行内存中的程序代码。</li><li>如果执行的程序占用内存很大或很多，或同时执行多个程序，就会导致内存消耗殆尽。从而导致程序执行异常或崩溃。</li></ul><h3 id="虚拟内存工作原理"><a href="#虚拟内存工作原理" class="headerlink" title="虚拟内存工作原理"></a>虚拟内存工作原理</h3><ul><li>当进程开始运行时，先将一部分程序装入内存，另一部分暂时留在外存；当要执行的指令不在内存时，由系统自动完成将它们调入内存的工作；当没有足够的内存时，系统自动选择部分内存（暂不执行的程序）空间，将其中原有的内容交换到磁盘上，并释放这些内存空间供其他进程使用。</li><li>这样做的结果使程序的运行丝毫不受影响，使程序在运行中感觉到拥有一个不受内存容量约束的、虚拟的、能够满足自己需求的存储器。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手，四次挥手</title>
      <link href="/2025/07/20/Eight-Part_Essay/Computer_Network/ThreeHandshakes_FourWaves/ThreeHandshakesFourWaves/"/>
      <url>/2025/07/20/Eight-Part_Essay/Computer_Network/ThreeHandshakes_FourWaves/ThreeHandshakesFourWaves/</url>
      
        <content type="html"><![CDATA[<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ul><li>第一次握手：SYN（最开始都是 CLOSE，之后服务器进入 LISTEN）<ol><li><strong>发起连接</strong>：客户端发送一个 TCP 报文段到服务器。这个报文段的头部中，SYN 位被设置为 1，表明这是一个连接请求。同时，客户端会随机选择一个序列号（Sequence Number），假设为 x，发送给服务器。</li><li><strong>目的</strong>：客户端通知服务器它希望建立连接，并告知服务器自己的初始序列号。</li><li><strong>状态</strong>：客户端进入 SYN_SENT 状态。</li></ol></li><li>第二次握手：SYN + ACK<ol><li>确认并应答：服务器收到客户端的连接请求后，如果同意建立连接，它会发送一个应答 TCP 报文段给客户端。在这个报文段中，SYN 位和 ACK 位都被设置为 1。服务器也会选择自己的一个随机序列号，假设为 y，并将客户端的序列号加 1（即 x+1）作为确认号（Acknowledgment Number），发送给客户端。</li><li>目的：服务器告诉客户端，它的连接请求被接受了，并通知客户端自己的初始序列号。</li><li>状态：服务器进入 SYN_RCVD 状态。</li></ol></li><li>第三次握手：ACK<ol><li>最终确认：客户端收到服务器的应答后，还需要向服务器发送一个确认。这个 TCP 报文段的 ACK 位被设置为 1，确认号被设置为服务器序列号加 1（即 y+1），而自己的序列号是 x+1。</li><li>目的：客户端确认收到了服务器的同步应答，完成三次握手，建立连接。</li><li>状态：客户端进入 ESTABLISHED 状态，当服务器接收到这个包时，也进入 ESTABLISHED 状态<br><img src="三次握手.jpg" alt="三次握手" style="zoom:50%;"></li></ol></li></ul><h3 id="为什么-TCP-握手不能是两次？"><a href="#为什么-TCP-握手不能是两次？" class="headerlink" title="为什么 TCP 握手不能是两次？"></a>为什么 TCP 握手不能是两次？</h3><ol><li>防止服务器一直等待。</li><li>防止客户端已经失效的连接请求突然又传送到了服务器。</li></ol><ul><li>例：客户端发起了 SYN=1 的第一次握手。服务器也及时回复了 SYN=2 和 ACK=1 的第二次握手，但是这个 ACK=1 的确认报文段因为某些原因在传输过程中丢失了，如果没有第三次握手告诉服务器，客户端收到了服务器的回应，那服务器是不知道客户端有没有接收到的。</li></ul><p><img src="二次握手.jpg" alt="二次握手" style="zoom:50%;"></p><ul><li>还有一种情况是，一个旧的、延迟的连接请求（SYN=1）被服务器接受，导致服务器错误地开启一个不再需要的连接。</li></ul><p><img src="响应失败请求.jpg" alt="响应失败请求" style="zoom:50%;"></p><ul><li>所以我们需要“三次握手”来确认这个过程：<ol><li>第一次握手：客户端发送 SYN 包（连接请求）给服务器，如果这个包延迟了，客户端不会一直等待，它可能会重试并发送一个新的连接请求。</li><li>第二次握手：服务器收到 SYN 包后，发送一个 SYN-ACK 包（确认接收到连接请求）回客户端。</li><li>第三次握手：客户端收到 SYN-ACK 包后，再发送一个 ACK 包给服务器，确认收到了服务器的响应。</li></ol></li></ul><h3 id="第三次握手可以携带数据吗？"><a href="#第三次握手可以携带数据吗？" class="headerlink" title="第三次握手可以携带数据吗？"></a>第三次握手可以携带数据吗？</h3><ul><li>第 3 次握手是可以携带数据的。</li><li>此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，它已经建立连接成功，并且确认服务端的接收和发送能力是正常的。</li><li>第一次握手不能携带数据是出于安全的考虑，因为如果允许携带数据，攻击者每次在 SYN 报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成 CPU 和内存的消耗。</li></ul><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ul><li>第一次挥手（FIN）：客户端向服务器发送一个 FIN（结束）报文，表示客户端没有数据要发送了，但仍然可以接收数据。客户端进入 FIN-WAIT-1 状态。</li><li>第二次挥手（ACK）：服务器接收到 FIN 报文后，向客户端发送一个 ACK 报文，确认已接收到客户端的 FIN 请求。服务器进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。</li><li>第三次挥手（FIN）：服务器向客户端发送一个 FIN 报文，表示服务器也没有数据要发送了。服务器进入 LAST-ACK 状态。</li><li>第四次挥手（ACK）：客户端接收到 FIN 报文后，向服务器发送一个 ACK 报文，确认已接收到服务器的 FIN 请求。客户端进入 TIME-WAIT 状态，等待一段时间以确保服务器接收到 ACK 报文。服务器接收到 ACK 报文后进入 CLOSED 状态。客户端在等待一段时间后也进入 CLOSED 状态。<br><img src="四次挥手.jpg" alt="四次挥手" style="zoom:50%;"></li></ul><h3 id="TCP-挥手为什么需要四次呢？"><a href="#TCP-挥手为什么需要四次呢？" class="headerlink" title="TCP 挥手为什么需要四次呢？"></a>TCP 挥手为什么需要四次呢？</h3><ul><li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</li><li>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。</li></ul><h3 id="TCP-四次挥手过程中，为什么需要等待-2MSL-才进入-CLOSED-关闭状态？"><a href="#TCP-四次挥手过程中，为什么需要等待-2MSL-才进入-CLOSED-关闭状态？" class="headerlink" title="TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？"></a>TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？</h3><h4 id="为什么需要等待？"><a href="#为什么需要等待？" class="headerlink" title="为什么需要等待？"></a>为什么需要等待？</h4><ol><li><strong>为了保证客户端发送的最后一个 ACK 报文段能够到达服务端</strong>。 这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的服务端就收不到对已发送的 FIN + ACK 报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 CLOSED 状态。</li><li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</li></ol><h4 id="为什么等待的时间是-2MSL？"><a href="#为什么等待的时间是-2MSL？" class="headerlink" title="为什么等待的时间是 2MSL？"></a>为什么等待的时间是 2MSL？</h4><ul><li>MSL 是 Maximum Segment Lifetime，报文最大生存时间，<strong>它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃</strong>。</li><li>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。</li><li>例：被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</li></ul><hr><h2 id="TCP-三次握手和四次挥手，中间失败了会发生什么？"><a href="#TCP-三次握手和四次挥手，中间失败了会发生什么？" class="headerlink" title="TCP 三次握手和四次挥手，中间失败了会发生什么？"></a>TCP 三次握手和四次挥手，中间失败了会发生什么？</h2><h3 id="TCP-三次握手丢包情况"><a href="#TCP-三次握手丢包情况" class="headerlink" title="TCP 三次握手丢包情况"></a>TCP 三次握手丢包情况</h3><h4 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h4><ul><li>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 SYN_SENT 状态。</li><li>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</li><li>不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。</li><li>当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？</li><li>在 Linux 里，客户端的 SYN 报文最大重传次数由 <code>tcp_syn_retries</code> 内核参数控制，这个参数是可以自定义的，默认值一般是 5。</li><li>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。<strong>每次超时的时间是上一次的 2 倍</strong>。</li><li>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。</li><li>所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。</li></ul><p><img src="超时握手一.png" alt="第一次握手丢包过程图解" style="zoom:50%;"></p><ul><li>小结：当客户端超时重传 3 次 SYN 报文后，由于 tcp_syn_retries 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</li></ul><h4 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h4><ul><li>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 SYN_RCVD 状态。</li><li><p>第二次握手的 SYN-ACK 报文其实有两个目的 ：</p><ol><li>第二次握手里的 ACK， 是对第一次握手的确认报文；</li><li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li></ol></li><li><p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</p></li><li>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。</li><li>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</li><li>在 Linux 下，SYN-ACK 报文的最大重传次数由 tcp_synack_retries内核参数决定，默认值是 5。</li><li>因此，<strong>当第二次握手丢失了，客户端和服务端都会重传</strong>：<ol><li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code> 内核参数决定；</li><li>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</li></ol></li><li><strong>举个例子</strong>：<ul><li>假设 tcp_syn_retries 参数值为 1，tcp_synack_retries 参数值为 2，那么当第二次握手一直丢失时，发生的具体过程如下：<ol><li>当客户端超时重传 1 次 SYN 报文后，由于 tcp_syn_retries 为 1，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</li><li>当服务端超时重传 2 次 SYN-ACK 报文后，由于 tcp_synack_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。</li></ol></li></ul></li></ul><p><img src="超时握手二.png" alt="第二次握手丢包过程图解" style="zoom:50%;"></p><h4 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h4><ul><li>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 ESTABLISH 状态。</li><li>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会<strong>触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数</strong>。</li><li><strong>注意：ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</li><li><strong>举个例子</strong><ul><li>假设 tcp_synack_retries 参数值为 2，那么当第三次握手一直丢失时，发生的过程如下：<ol><li>当服务端超时重传 2 次 SYN-ACK 报文后，由于 tcp_synack_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍）</li><li>如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。</li></ol></li></ul></li></ul><p><img src="超时握手三.png" alt="第三次握手丢包过程图解" style="zoom:50%;"></p><h3 id="TCP-四次挥手丢包情况"><a href="#TCP-四次挥手丢包情况" class="headerlink" title="TCP 四次挥手丢包情况"></a>TCP 四次挥手丢包情况</h3><h4 id="第一次挥手丢失了，会发生什么？"><a href="#第一次挥手丢失了，会发生什么？" class="headerlink" title="第一次挥手丢失了，会发生什么？"></a>第一次挥手丢失了，会发生什么？</h4><ul><li>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 <code>FIN_WAIT_1</code> 状态。</li><li>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 <code>FIN_WAIT2</code> 状态。</li><li>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 <code>tcp_orphan_retries</code> 参数控制。</li><li>当客户端重传 FIN 报文的次数超过 <code>tcp_orphan_retries</code> 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 <code>close</code> 状态。</li><li><strong>举个例子</strong><ul><li>假设 <code>tcp_orphan_retries</code> 参数值为 3，当第一次挥手一直丢失时，发生的过程如下:<ol><li>当客户端超时重传 3 次 FIN 报文后，由于 tcp_orphan_retries 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍）</li><li>如果还是没能收到服务端的第二次挥手（ACK报文），那么客户端就会断开连接。</li></ol></li></ul></li></ul><p><img src="超时挥手一.png" alt="第一次挥手丢包过程图解" style="zoom:50%;"></p><h4 id="第二次挥手丢失了，会发生什么？"><a href="#第二次挥手丢失了，会发生什么？" class="headerlink" title="第二次挥手丢失了，会发生什么？"></a>第二次挥手丢失了，会发生什么？</h4><ul><li>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 <code>CLOSE_WAIT</code> 状态。</li><li>在前面我们也提了，<strong>ACK 报文是不会重传的</strong>，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</li><li>举个例子：<ul><li>假设 tcp_orphan_retries 参数值为 2，当第二次挥手一直丢失时，发生的过程如下：<ol><li>当客户端超时重传 2 次 FIN 报文后，由于 tcp_orphan_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍）</li><li>如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。</li></ol></li></ul></li></ul><p><img src="超时挥手二.png" alt="第二次挥手丢包过程图解" style="zoom:50%;"></p><ul><li>这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 <code>FIN_WAIT2</code> 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。</li><li>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以FIN_WAIT2 状态不可以持续太久，而 tcp_fin_timeout 控制了这个状态下连接的持续时长，默认值是 60 秒。</li><li>这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭，如下：</li></ul><p><img src="超时挥手三前.png" alt="第三次挥手前丢包过程图解" style="zoom:50%;"></p><ul><li>但是注意，如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。</li><li>此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 <code>FIN_WAIT2</code> 状态（<code>tcp_fin_timeout</code> 无法控制 shutdown 关闭的连接）。如下图：</li></ul><p><img src="超时挥手三前接收.png" alt="第三次挥手前丢包过程图解" style="zoom:50%;"></p><h4 id="第三次挥手丢失了，会发生什么？"><a href="#第三次挥手丢失了，会发生什么？" class="headerlink" title="第三次挥手丢失了，会发生什么？"></a>第三次挥手丢失了，会发生什么？</h4><ul><li>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 CLOSE_WAIT 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</li><li>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。</li><li>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。</li><li>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 tcp_orphan_retries 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</li><li><strong>举个例子</strong>：<ul><li>假设 tcp_orphan_retries = 3，当第三次挥手一直丢失时，发生的过程如下：<ol><li>当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcp_orphan_retries 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。</li><li>客户端因为是通过 close 函数关闭连接的，处于 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。</li></ol></li></ul></li></ul><p><img src="超时挥手三.png" alt="第三次挥手丢包过程图解" style="zoom:50%;"></p><h4 id="第四次挥手丢失了，会发生什么？"><a href="#第四次挥手丢失了，会发生什么？" class="headerlink" title="第四次挥手丢失了，会发生什么？"></a>第四次挥手丢失了，会发生什么？</h4><ul><li>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 TIME_WAIT 状态。</li><li>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。</li><li>然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。</li><li>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 tcp_orphan_retries 参数控制。</li><li><strong>举个例子</strong><ul><li>假设 tcp_orphan_retries 为 2，当第四次挥手一直丢失时，发生的过程如下：<ol><li>当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。</li><li>客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</li></ol></li></ul></li></ul><p><img src="超时挥手四.png" alt="第四次挥手丢包过程图解" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> 八股文 - 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 长连接和短连接</title>
      <link href="/2025/07/20/Eight-Part_Essay/Computer_Network/TCP_Long_And_Short_Connections/TCPLongAndShortConnections/"/>
      <url>/2025/07/20/Eight-Part_Essay/Computer_Network/TCP_Long_And_Short_Connections/TCPLongAndShortConnections/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-长连接和短连接"><a href="#TCP-长连接和短连接" class="headerlink" title="TCP 长连接和短连接"></a>TCP 长连接和短连接</h2><h3 id="什么是长连接和短连接"><a href="#什么是长连接和短连接" class="headerlink" title="什么是长连接和短连接"></a>什么是长连接和短连接</h3><ul><li><strong>长连接（long connnection）</strong>，指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。</li><li><strong>短连接（short connnection）</strong>，是相对于长连接而言的概念，指的是在数据传送过程中，只在需要发送数据时才去建立一个连接，数据发送完成后则断开此连接，即每次连接只完成一项业务的发送。</li></ul><p><img src="长连接短连接.png" alt="长连接短连接" style="zoom:100%;"></p><h3 id="TCP-长短连接的优势"><a href="#TCP-长短连接的优势" class="headerlink" title="TCP 长短连接的优势"></a>TCP 长短连接的优势</h3><h4 id="TCP-短连接"><a href="#TCP-短连接" class="headerlink" title="TCP 短连接"></a>TCP 短连接</h4><ul><li>模拟一下TCP短连接的情况：<code>client</code> 向 <code>server</code> 发起连接请求，<code>server</code> 接到请求，然后双方建立连接。<code>client</code> 向 <code>server</code> 发送消息，<code>server</code> 回应 <code>client</code> ，然后一次读写就完成了，这时候双方任何一个都可以发起 <code>close</code> 操作，不过一般都是 <code>client</code> 先发起 <code>close</code> 操作。</li><li>从上面的描述看，短连接一般只会在 <code>client/server</code> 间传递一次读写操作。</li><li><strong>短连接优点</strong>：管理起来方便，存在的连接都是有效的连接，不需要额外的控制手段。</li></ul><h4 id="TCP-长连接"><a href="#TCP-长连接" class="headerlink" title="TCP 长连接"></a>TCP 长连接</h4><ul><li>模拟一下TCP长连接的情况，<code>client</code> 向 <code>server</code> 发起连接，<code>server</code> 接受 <code>client</code> 连接，双方建立连接。<code>Client</code> 与 <code>server</code> 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。下面介绍一下 TCP 的<strong>保活功能</strong>。</li><li>TCP 的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。</li><li>如果一个给定的连接在<strong>两小时内</strong>没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下 <code>4</code> 个状态之一：<ol><li><strong>客户主机依然正常运行，并从服务器可达</strong>。客户的 TCP 响应正常，而服务器也知道对方是正常的，服务器在<strong>两小时</strong>后将保证定时器复位。</li><li><strong>客户主机已经崩溃，并且关闭或者正在重新启动</strong>。在任何一种情况下，客户的 TCP 都没有响应。服务端将不能收到对探测的响应，并在 <code>75秒</code> 后超时。服务器总共发送 <code>10</code> 个这样的探测 ，每个间隔 <code>75秒</code> 。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li><li><strong>客户主机崩溃并已经重新启动</strong>。服务器将收到一个对其保证探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li><li><strong>客户机正常运行，但是服务器不可达</strong>。这种情况与 <code>2</code> 类似，TCP 能发现的就是没有收到探查的响应。</li></ol></li><li>在长连接的应用场景下，client 端一般不会主动关闭它们之间的连接，client 与 server 之间的连接如果一直不关闭的话，会存在一个问题：随着客户端连接越来越多，server 早晚有扛不住的时候，这时候 server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 server 端服务受损。如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</li></ul><p>长连接和短连接的产生在于 client 和 server 采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p><h3 id="HTTP-与-TCP-IP"><a href="#HTTP-与-TCP-IP" class="headerlink" title="HTTP 与 TCP / IP"></a>HTTP 与 TCP / IP</h3><ul><li>关于HTTP和TCP/IP各协议的详细介绍：<a href="https://blog.csdn.net/yeahPeng11/article/details/117486184">计算机网络 - 学习总结篇</a></li></ul><h4 id="HTTP-协议与-TCP-IP-协议的关系"><a href="#HTTP-协议与-TCP-IP-协议的关系" class="headerlink" title="HTTP 协议与 TCP / IP 协议的关系"></a>HTTP 协议与 TCP / IP 协议的关系</h4><ul><li><strong>HTTP 协议的长连接和短连接，本质上是 TCP 协议的长连接和短连接</strong></li><li>HTTP 属于应用层协议，在传输层使用 TCP 协议，在网络层使用 IP 协议。</li><li>IP 协议主要解决网络路由和寻址问题，TCP 协议主要解决如何在 IP 层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且接受顺序与发送顺序一致。TCP 协议是可靠的、面向连接的。</li><li><strong>TCP 才负责连接，只有负责传输的这一层才需要建立连接</strong></li><li>在 <code>HTTP/1.0</code> 中默认使用短连接。从 <code>HTTP/1.1</code> 起，默认使用长连接。</li></ul><h4 id="如何理解HTTP协议是无状态的"><a href="#如何理解HTTP协议是无状态的" class="headerlink" title="如何理解HTTP协议是无状态的"></a>如何理解HTTP协议是无状态的</h4><ul><li>HTTP 协议是无状态的，指的是 HTTP 协议对事务处理没有记忆能力，服务器不知道客户端是什么状态。即第一次和第二次发起对应的请求之间没有任何联系。</li></ul><h3 id="长轮询与短轮询"><a href="#长轮询与短轮询" class="headerlink" title="长轮询与短轮询"></a>长轮询与短轮询</h3><h4 id="什么是长轮询与短轮询"><a href="#什么是长轮询与短轮询" class="headerlink" title="什么是长轮询与短轮询"></a>什么是长轮询与短轮询</h4><ul><li><strong>短轮询</strong>：比如你现在要做一个电商中商品详情的页面，这个详情界面中有一个字段是库存量。而这个库存量需要实时的变化，保持和服务器里实际的库存一致。最简单的一种方式，就是不停地去请求服务器中的库存量是多少，然后刷新到这个页面当中，这其实就是所谓的短轮询。这种方式有明显的坏处，如果有 1000 个人停留在某个商品详情页面，那就是说会有 1000 个客户端不停的去请求服务器获取库存量，这显然是不合理的。</li><li><strong>长轮询</strong>：短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。而长轮询则不是，在长轮询中，服务器如果检测到库存量没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测库存量有没有变化，检测到变化就立即返回，否则就一直等到超时为止。</li><li>但是长轮询也是有坏处的，因为把请求挂起同样会导致资源的浪费，假设还是 1000 个人停留在某个商品详情页面，那就很有可能服务器这边挂着 1000 个线程，在不停检测库存量，这依然是有问题的。</li></ul><h4 id="长短轮询和长短连接的区别"><a href="#长短轮询和长短连接的区别" class="headerlink" title="长短轮询和长短连接的区别"></a>长短轮询和长短连接的区别</h4><ul><li><strong>长短轮询</strong>：区别在于决定的方式。一个 TCP 连接是否为长连接，是通过设置 HTTP 的 Connection Header 来决定的，而且是需要两边（服务器端与应用端）都设置才有效。而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系。</li><li><strong>长短连接</strong>：区别在于实现的方式。连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局域网中的主机之间通信</title>
      <link href="/2025/07/20/Eight-Part_Essay/Computer_Network/Communication_Between_Hosts/CommunicationBetweenHosts/"/>
      <url>/2025/07/20/Eight-Part_Essay/Computer_Network/Communication_Between_Hosts/CommunicationBetweenHosts/</url>
      
        <content type="html"><![CDATA[<h2 id="局域网中的主机之间通信"><a href="#局域网中的主机之间通信" class="headerlink" title="局域网中的主机之间通信"></a>局域网中的主机之间通信</h2><ul><li>局域网中的主机间通信分为 2 种：<ol><li>两台主机处于同一网段</li><li>两台主机之间处于不同网段</li></ol></li></ul><h3 id="局域网中处于同一网段中的主机通信"><a href="#局域网中处于同一网段中的主机通信" class="headerlink" title="局域网中处于同一网段中的主机通信"></a>局域网中处于同一网段中的主机通信</h3><ul><li>假如：主机 <code>A</code> 要和主机 <code>B</code> 通信，主机 <code>A</code> 知道主机 <code>B</code> 的 IP 地址。知道 IP 地址是通信的前提。首先，要通进行通信，IP 地址和 MAC 地址是必不可少的，IP 地址已经知道了，那么主机 <code>A</code> 必须要知道主机 <code>B</code> 的 MAC 地址，先在 <code>ARP</code> 表中查看有无该 IP 地址，如果有，就找出对应的硬件 MAC 地址，如果没有，<strong>主机 <code>A</code> 广播发送 <code>ARP</code> 请求来获取目的 MAC 地址，说 who is 192.168.1.102 ?</strong></li></ul><p><img src="处于同一网段.png" alt="局域网中处于同一网段中的主机通信" style="zoom:100%;"></p><ul><li>当 IP 地址是 <code>192.168.1.102</code> 的主机 <code>B</code> 收到后，会回复主机 <code>A</code> ，说 <strong>“我是 <code>192.168.1.102</code> ，我的 MAC 地址是：xx-xx-xx-xx-xx-xx”（ARP应答）</strong>。这样一来，主机 <code>A</code> 就知道主机 <code>B</code> 的 MAC 地址了，当然，由于主机 <code>A</code> 在广播发送的 <code>ARP</code> 报文时，主机 <code>A</code> 的 MAC 地址被作为源 MAC 地址而封装在 MAC 帧中，所以主机 <code>B</code> 收到广播报文后也会知道主机 <code>A</code> 的 MAC 地址，这时，主机 <code>A</code> 的源 IP 地址、目的 IP 地址、源 MAC 地址和目的 MAC 地址都能确定了，就能够进行通信了。这也就是平时说的同一网段中的主机相互通信。</li></ul><h3 id="不同网段间主机通信"><a href="#不同网段间主机通信" class="headerlink" title="不同网段间主机通信"></a>不同网段间主机通信</h3><ul><li>这里的不同网段，指的是不在同一子网下。</li><li>假如：主机 <code>A</code> 要和主机 <code>D</code> 进行通信，那么同样的，主机 <code>A</code> 如果广播发送 <code>ARP</code> 请求，询问 <code>192.168.1.22</code> 在哪里，很显然，主机 <code>A</code> 和主机 <code>D</code> 不在同一个网段内，路由器默认不转发广播报文，那么主机 <code>D</code> 就收不到 <code>ARP</code> 请求，也就无法回应主机 <code>A</code> ，主机 <code>A</code> 也就无从获取主机 <code>D</code> 的MAC地址。</li></ul><p><img src="处于不同网段.png" alt="不同网段间主机通信" style="zoom:100%;"></p><ul><li>其实，<strong>主机 <code>A</code> 会首先检查目的 IP 地址是否与自己在同一网段</strong>，如果在，就直接广播 <code>ARP</code> 请求来获取目的主机的 MAC 地址，<strong>如果不在同一网段，又配置有网关地址的话，那么主机 <code>A</code> 就通过 <code>ARP</code> 请求，询问 <code>192.168.0.1</code>（网关）在哪里</strong>，网关收到后就会回应主机 <code>A</code> ，把网关的 MAC 地址告诉主机 <code>A</code> ，当获取到网关的 MAC 地址后，把网关的 MAC 地址作为 MAC 帧中的目的 MAC 地址，然后就把数据丢给网关 <code>192.168.0.1</code> ，网关根据路由表，转发给下一个路由器，再由下一个路由器交付给主机 <code>D</code> 所在的网络，即网关，网关再通过 <code>ARP</code> ，找到目的主机 <code>D</code> ，完成数据交付。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎玉零珠————计算机网络</title>
      <link href="/2025/07/20/Eight-Part_Essay/Computer_Network/Broken_Jade_Beads/BrokenJadeBeads/"/>
      <url>/2025/07/20/Eight-Part_Essay/Computer_Network/Broken_Jade_Beads/BrokenJadeBeads/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h2><ul><li>理论上的网络通信模型</li><li><strong>应用层</strong>：最靠近用户的层，负责处理特定的应用程序细节。这一层提供了网络服务与用户应用软件之间的接口。例如，Web 浏览器、FTP 客户端和服务器、电子邮件客户端等。</li><li><strong>表示层</strong>：确保从一个系统发送的信息可以被另一个系统的应用层读取。它负责数据的转换、压缩和加密。例如，确保数据从一种编码格式转换为另一种，如 ASCII 到 EBCDIC。</li><li><strong>会话层</strong>：管理用户的会话，控制网络上两节点间的对话和数据交换的管理。它负责建立、维护和终止会话。例如，建立一个会话令牌，以便在网络上的两个节点之间传递。</li><li><strong>传输层</strong>：提供端到端的通信服务，保证数据的完整性和正确顺序。这一层包括 TCP 和 UDP 等。</li><li><strong>网络层</strong>：负责在多个网络之间进行数据传输，确保数据能够在复杂的网络结构中找到从源到目的地的最佳路径。这层使用的是 IP（Internet Protocol）协议。</li><li><strong>数据链路层</strong>：在物理连接中提供可靠的传输，负责建立和维护两个相邻节点间的链路。包括帧同步、MAC（媒体访问控制）。</li><li><strong>物理层</strong>：负责在物理媒介上实现原始的数据传输，比如电缆、光纤和无线信号传输。涉及的内容包括电压、接口、针脚、电缆的规格和传输速率等。</li></ul><h2 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP / IP 四层模型"></a>TCP / IP 四层模型</h2><ul><li>实际应用层面上的网络通信模型</li><li>是互联网通信的核心，定义了一系列协议和标准，确保设备间可以可靠地进行数据传输。</li><li><strong>应用层（Application Layer）</strong>：直接面向用户和应用程序，提供各种网络服务。它包含了用于特定应用的协议和服务，如 HTTP（HyperText Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）等。</li><li><strong>传输层（Transport Layer）</strong>：提供端到端的通信服务，确保数据可靠传输。它负责分段数据、流量控制、错误检测和纠正。常见的传输层协议有 TCP 和 UDP。</li><li><strong>网际层：或者叫网络层（Internet Layer）</strong>：负责在不同网络之间路由数据包，提供逻辑地址（IP 地址）和网络寻址功能。用于处理数据包的分组、转发和路由选择，确保数据可以从源端传输到目标端。<strong>常见协议</strong>：IPv4、IPv6、ICMP（Internet Control Message Protocol）。<strong>示例</strong>：当访问一个网站时，网络层协议（如 IPv4）将你的请求从你的计算机通过多个路由器传输到目标服务器。</li><li><strong>网络接口层（Network Access Layer）</strong>：或者叫<strong>链路层（Link Layer）</strong>，负责将数字信号在物理通道（网线）中准确传输，定义了如何在单一网络链路上传输数据，如何处理数据帧的发送和接收，包括物理地址（MAC 地址）的解析。<strong>常见协议</strong>：以太网（Ethernet）、Wi-Fi。<strong>示例</strong>：在一个局域网（LAN）中，计算机通过以太网连接交换机，链路层协议负责数据帧在网络设备间的传输。</li></ul><h2 id="TCP-IP-五层体系结构"><a href="#TCP-IP-五层体系结构" class="headerlink" title="TCP / IP 五层体系结构"></a>TCP / IP 五层体系结构</h2><ul><li>五层结构是为了方便理解和记忆。</li><li>是对 OSI 和 TCP/IP 的折衷，它保留了 TCP/IP 的实用性，同时提供了比四层模型更细致的分层，便于教学和理解网络的各个方面。</li><li><strong>应用层</strong>：作为网络服务和最终用户之间的接口。它提供了一系列供应用程序使用的协议，如 HTTP（网页）、FTP（文件传输）、SMTP（邮件传输）等。使用户的应用程序可以访问网络服务。</li><li><strong>传输层</strong>：提供进程到进程的通信管理，这一层确保数据按顺序、无错误地传输。主要协议包括 TCP 和 UDP。</li><li><strong>网络层</strong>：负责数据包从源到目的地的传输和路由选择，包括跨越多个网络（即互联网）。它使用逻辑地址（如 IP 地址）来唯一标识设备。路由器是网络层设备。</li><li><strong>数据链路层</strong>：确保从一个节点到另一个节点的可靠、有效的数据传输。交换机、网桥是数据链路层设备。</li><li><strong>物理层</strong>：电缆、光纤、无线电频谱、网络适配器等。</li></ul><p><img src="三种网络体系结构.jpg" alt="三种网络体系结构" style="zoom:50%;"></p><h2 id="TCP三次握手四次挥手工作在哪一层？"><a href="#TCP三次握手四次挥手工作在哪一层？" class="headerlink" title="TCP三次握手四次挥手工作在哪一层？"></a>TCP三次握手四次挥手工作在哪一层？</h2><ul><li>三次握手和四次挥手都是工作在传输层。传输层（Transport Layer）是 OSI 模型的第四层，负责提供端到端的通信服务，包括数据传输的建立、维护和终止。</li><li>TCP 作为一种面向连接的协议，通过三次握手建立连接，通过四次挥手终止连接，确保数据传输的可靠性和完整性。</li></ul><h2 id="TCP-的粘包和拆包"><a href="#TCP-的粘包和拆包" class="headerlink" title="TCP 的粘包和拆包"></a>TCP 的粘包和拆包</h2><ul><li>TCP 是面向流，没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，<strong>一个完整的包可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送</strong>。这就是所谓的 TCP 粘包和拆包问题。<br><img src="粘包和拆包.jpg" alt="粘包和拆包" style="zoom:50%;"></li></ul><blockquote><ul><li><strong>为什么会产生粘包和拆包 ?</strong></li></ul><blockquote><ul><li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li><li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li><li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；</li><li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 &gt; MSS。</li></ul></blockquote><ul><li><strong>如何解决 ?</strong></li></ul><blockquote><ul><li>发送端将每个数据包封装为固定长度；</li><li>在数据尾部增加特殊字符进行分割；</li><li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</li></ul></blockquote></blockquote><h2 id="如何设计使UDP的上层（应用层）可以可靠传输数据（速记版）"><a href="#如何设计使UDP的上层（应用层）可以可靠传输数据（速记版）" class="headerlink" title="如何设计使UDP的上层（应用层）可以可靠传输数据（速记版）"></a>如何设计使UDP的上层（应用层）可以可靠传输数据（速记版）</h2><ul><li>既然UDP的传输层不可靠，那么只能从UDP的应用层入手了。在不考虑阻塞的情况下，可以参考TCP:<ol><li>添加seq/ack机制，确保对端可以正确接收数据。</li><li>添加发送和接收缓存区，主要是为了应对超时数据重传问题。</li><li>添加超时数据重传机制，确保数据不会丢失。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚函数与虚表</title>
      <link href="//Eight-Part_Essay/C++/Virtual_Functions_And_Virtual_Tables/"/>
      <url>//Eight-Part_Essay/C++/Virtual_Functions_And_Virtual_Tables/</url>
      
        <content type="html"><![CDATA[<h2 id="虚函数与虚表"><a href="#虚函数与虚表" class="headerlink" title="虚函数与虚表"></a>虚函数与虚表</h2><p><img src="虚函数(1).jpg" alt="虚函数" style="zoom:100%;"><br><img src="虚函数(2).jpg" alt="虚函数" style="zoom:100%;"></p><h3 id="普通类的内存布局和带虚函数类的内存布局"><a href="#普通类的内存布局和带虚函数类的内存布局" class="headerlink" title="普通类的内存布局和带虚函数类的内存布局"></a>普通类的内存布局和带虚函数类的内存布局</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonVirtualClass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualClass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of NonVirtualClass: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(NonVirtualClass) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of VirtualClass: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(VirtualClass) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这里 <code>NonVirtualClass</code> 的大小为1，而 <code>VirtualClass</code> 的大小为8（64位情况），有两个原因造成两者的不同：<ol><li>C++中类的大小不能为0，所以一个空类的大小为 <code>1</code> , 如果对一个空类对象取地址，如果大小为0，这个地址就没法取了。</li><li>如果一个空类有虚函数，那其内存布局中只有一个虚表指针，其大小为 <code>sizeof(void*)</code> , 即 <code>8</code>。</li></ol></li></ul><h3 id="单继承下类的虚表布局"><a href="#单继承下类的虚表布局" class="headerlink" title="单继承下类的虚表布局"></a>单继承下类的虚表布局</h3><h4 id="虚表布局（按顺序）"><a href="#虚表布局（按顺序）" class="headerlink" title="虚表布局（按顺序）"></a>虚表布局（按顺序）</h4><ol><li><code>type_info</code></li><li><code>父类虚函数</code>：未被子类重写的虚函数，其地址保留在虚表中。</li><li><code>​子类覆盖的虚函数</code>：子类重写的虚函数地址会替换父类虚表中的对应条目。</li><li><code>新增虚函数</code>：子类新增的虚函数地址追加到虚表末尾。</li></ol><ul><li><strong>在单继承中，派生类的虚表继承自基类</strong>，并且派生类覆盖的虚函数地址会替换基类虚表中的对应条目。</li></ul><h4 id="type-info-布局"><a href="#type-info-布局" class="headerlink" title="type_info 布局"></a>type_info 布局</h4><ol><li>辅助类地址，用来实现 <code>type_info</code> 的函数</li><li>类名地址</li><li>父类 <code>type_info</code> 地址</li></ol><h4 id="Dynamic-Cast（RTTI）"><a href="#Dynamic-Cast（RTTI）" class="headerlink" title="Dynamic Cast（RTTI）"></a>Dynamic Cast（RTTI）</h4><ul><li><code>dynamic_cast</code> 通过检查虚表中 <code>type_info</code> 的信息判断能否在运行时进行指针转型以及是否需要指针偏移，需要插入额外的操作，这也解释了 <code>dynamic_cast</code> 的开销问题。</li></ul><h3 id="多继承下类的虚表布局"><a href="#多继承下类的虚表布局" class="headerlink" title="多继承下类的虚表布局"></a>多继承下类的虚表布局</h3><p>费流版：<a href="https://blog.csdn.net/jhdhdhehej/article/details/132629781">多继承的虚表</a></p><ul><li><strong>当派生类同时继承多个包含虚函数的基类时，每个基类会维护独立的虚表指针（vptr）。派生类对象内存中会按继承顺序排列这些基类的虚表指针。</strong></li><li>以下为示例：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">// 覆盖Base1的func1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">// 覆盖Base2的func2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>Derived</code> 对象内存布局：<br>+—————————-+<br>| Base1虚表指针(vptr1)| → 指向Base1的虚表<br>| Base1成员变量      |<br>+—————————-+<br>| Base2虚表指针(vptr2)| → 指向Base2的虚表<br>| Base2成员变量      |<br>+—————————-+<br>| Derived成员变量    |<br>+—————————-+</li><li><strong>虚表覆盖规则​：</strong><br>派生类重写的虚函数会替换对应基类虚表中的条目，但索引位置保持与基类一致。例如：<ol><li><code>vptr1</code> 指向的虚表中，<code>func1</code> 条目被替换为 <code>Derived::func1</code></li><li><code>vptr2</code> 指向的虚表中，<code>func2</code> 条目被替换为 <code>Derived::func2</code></li></ol></li><li><strong>新增虚函数的存储​</strong><br><strong>派生类新增的虚函数会被追加到第一个基类虚表的末尾</strong>。例如若 <code>Derived</code> 新增 <code>func3()</code> ，则 <code>vptr1</code> 指向的虚表末尾会新增该函数指针。</li><li><strong>在多继承中，每个基类有自己独立的虚表</strong>。派生类覆盖的虚函数会替换对应基类虚表中的函数地址。</li></ul><h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><ul><li>与上述（普通的多继承）相同</li></ul><h4 id="菱形虚拟继承"><a href="#菱形虚拟继承" class="headerlink" title="菱形虚拟继承"></a>菱形虚拟继承</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;A::func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.B::_a = <span class="number">1</span>;</span><br><span class="line">    d.C::_a = <span class="number">2</span>;</span><br><span class="line">    d._b = <span class="number">3</span>;</span><br><span class="line">    d._c = <span class="number">4</span>;</span><br><span class="line">    d._d = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据菱形虚拟继承的对象模型，不难得出以下的内存图</li></ul><p><img src="菱形虚拟继承内存图.png" alt="菱形虚拟继承内存图" style="zoom:100%;"></p><ul><li><code>B</code> 和 <code>C</code> 均有 虚表指针（第一个）和虚基表指针（第二个）</li><li>对于虚基表里面的内容， 它里面存储的是 <code>偏移量</code> ，第一个是 <code>-4</code> ，第二个是 <code>18</code> ，可见，第一个值是为了找到该部分的起始位置，第二个值是为了找到 <code>A</code> 的部分</li><li>那么如果我们给 <code>D</code> 有自己单独的虚函数呢？<code>D</code> 会额外创建虚表吗？其实不会的，因为 <code>D</code> 完全可以存在已有的虚表里。我们可能会以为放入共享的 <code>A</code> 的虚表，不过如果按照多继承的角度去理解，也有可能会放入 <code>B</code> 的虚表。</li><li>菱形虚拟继承会将 <code>B</code> 和 <code>C</code> 中的 <code>A</code> 都放到了公共部分</li><li>此时的按照菱形虚拟继承的内存分配来看是没有什么大问题的，但是当我们 <code>B</code> 和 <code>C</code> 同时对 <code>A</code> 的虚函数进行了重写的时候，由于是菱形虚拟继承，所以都会让 <code>A</code> 给放到公共部分（ <code>B</code> 和 <code>C</code> 共享的 <code>A</code> ）。两个都一起重写，导致编译器不知道什么该听哪一个的，所以会报错</li><li>主要还是因为 <code>B</code> 和 <code>C</code> 都想要去重写这个 <code>A</code> ，才导致的问题。而如果只是一个菱形继承的话，就不会出现这个问题，因为各自重写各自的即可。</li><li>对于上面的情况，有两种方案去处理：<ol><li>只保留一种（ <code>B</code> 或 <code>C</code> ）重写即可</li><li>让 <code>D</code> 再来一个重写，这样的话，无论 <code>B</code> 和 <code>C</code> 是否重写，都要听 <code>D</code> 的重写函数了。</li></ol></li></ul><h3 id="RTTI-有什么用？怎么用？"><a href="#RTTI-有什么用？怎么用？" class="headerlink" title="RTTI 有什么用？怎么用？"></a>RTTI 有什么用？怎么用？</h3><h4 id="RTTI-的用途"><a href="#RTTI-的用途" class="headerlink" title="RTTI 的用途"></a>RTTI 的用途</h4><ul><li>假设有一个类层次结构，其中的类都是从一个基类派生而来的，则可以让基类指针指向其中任何一个类的对象。</li><li>有时候我们会想要知道指针具体指向的是哪个类的对象。因为：<ol><li>可能希望调用类方法的正确版本，而有时候派生对象可能包含不是继承而来的方法，此时，只有某些类的对象可以使用这种方法。</li><li>也可能是出于调试目的，想跟踪生成的对象的类型。</li></ol></li></ul><h4 id="RTTI-的工作原理"><a href="#RTTI-的工作原理" class="headerlink" title="RTTI 的工作原理"></a>RTTI 的工作原理</h4><ul><li>C++有3个支持RTTI的元素：<ol><li>如果可能的话，<code>dynamic_cast</code> 运算符将使用一个指向基类的指针来生成一个指向派生类的指针；否则，该运算符返回 0（空指针）；</li><li><code>typeid</code> 运算符返回一个指出对象的类型的值；</li><li><code>type_info</code> 结构存储了有关特定类型的信息。</li></ol></li><li><strong>注意：RTTI 只适用于包含虚函数的类</strong>。因为只有对于这种类层次结构，才应该将派生类的地址赋给基类指针。</li><li>RTTI的初衷就是运行阶段类型判断，以便debug或者类型判断后调用派生类与基类的非公有类。可以考虑把派生类成员函数实现放在基类作为虚函数，派生类中实现，直接利用基类调用虚函数以调用到派生类的虚函数实现。</li></ul><h4 id="dynamic-cast-运算符"><a href="#dynamic-cast-运算符" class="headerlink" title="dynamic_cast 运算符"></a>dynamic_cast 运算符</h4><ul><li>这是最常用的 RTTI 组件，它不能回答 <code>指针指向的是哪类对象</code> 这样的问题，但能够回答 <code>是否可以安全地将对象的地址赋给特定类型的指针</code> 这样的问题。说白了，就是看看<strong>这个对象指针能不能转换为目标指针</strong>。</li><li>通常，如果指向的对象（*pt）的类型为Type或者是从Type直接或简介派生而来的类型，则下面的表达式将指针pt转换为Type类型的指针：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;Type *&gt;(pt)</span><br></pre></td></tr></table></figure><ul><li>否则，结果为0，即空指针。</li><li><strong>注意</strong>：即使编译器支持RTTI，在默认情况下，它也可能关闭该特性。如果该特性被关闭，程序可能仍能够通过编译，但将出现运行阶段错误。在这种情况下，应该查看文档或菜单选项。</li><li>也可以将dynamic_cast用于引用，用法稍微有点不同。</li><li>没有与空指针对应的引用值，因此无法使用特殊的引用值来指示失败。当请求不正确时，<code>dynamic_cast</code> 将引发类型为 <code>bad_cast</code> 的异常，这种异常是从 <code>exception</code> 类派生而来的，它是在头文件 <code>typeinfo</code> 中定义的。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span> <span class="comment">// for bad_cast</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span> </span><br><span class="line">&#123;</span><br><span class="line">    Basic &amp; rs = <span class="built_in">dynamic_cast</span>&lt;Basic &amp;&gt;(rt);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(bad_cast &amp;)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="typeid运算符和type-info类"><a href="#typeid运算符和type-info类" class="headerlink" title="typeid运算符和type_info类"></a>typeid运算符和type_info类</h4><ul><li><code>typeid</code> 运算符能够用于确定两个对象是否为同种类型。它与sizeof有些想象，可以接受两种参数：<ol><li>类名</li><li>结果为对象的表达式</li></ol></li><li>返回一个对 <code>type_info</code> 对象的引用，其中，<code>type_info</code> 是在头文件 <code>typeinfo</code> 中定义的一个类，这个类重载了 <code>==</code> 和 <code>!=</code> 运算符，以便可以用于对类型进行比较。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断pg指向的是否是ClassName类的对象</span></span><br><span class="line"><span class="built_in">typeid</span>(ClassName) == <span class="built_in">typeid</span>(*pg)</span><br></pre></td></tr></table></figure><ul><li>如果 <code>pg</code> 是一个空指针，程序将引发 <code>bad_typeid</code> 异常，该异常是从 <code>exception</code> 类派生而来的，它是在头文件 <code>typeinfo</code> 中声明的。</li><li><code>type_info</code> 类的实现随厂商而异，但包含一个 <code>name()</code> 成员，该函数返回一个随实现而异的字符串，通常（但并非一定）是类的名称。可以这样显示：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Now processing type is &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(*pg).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;.\\n&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>其实，<code>typeid</code> 运算符就是指出或判断具体的类型，而 <code>dynamic_cast</code> 运算符主要用于判断是否能够转换，并进行类型转换（指针或引用）。</li></ul><h4 id="误用-RTTI-的例子"><a href="#误用-RTTI-的例子" class="headerlink" title="误用 RTTI 的例子"></a>误用 RTTI 的例子</h4><ul><li>有些人对 <code>RTTI</code> 口诛笔伐，认为它是多余的，会导致程序效率低下和糟糕的编程方式。这里有一个需要尽量避免的例子。</li><li>在判断是否能调用某个方法时，尽量不要使用 <code>if-else</code> 和 <code>typeid</code> 的形式，因为这会使得代码冗长。</li><li>如果在扩展的 <code>if else</code> 语句系列中使用了 <code>typeid</code> ，则应该考虑是否应该使用 <code>虚函数</code> 和 <code>dynamic_cast</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚调用</title>
      <link href="//Eight-Part_Essay/C++/Virtual_Call/"/>
      <url>//Eight-Part_Essay/C++/Virtual_Call/</url>
      
        <content type="html"><![CDATA[<h2 id="虚调用的定义"><a href="#虚调用的定义" class="headerlink" title="虚调用的定义"></a>虚调用的定义</h2><ul><li><code>虚调用</code> 是相对于 <code>实调用</code> 而言，它的本质是 <code>动态联编</code> 。</li><li>在发生函数调用的时候，如果函数的入口地址是<strong>在编译阶段静态确定的</strong>，就是是 <code>实调用</code> 。</li><li>如果函数的入口地址要<strong>在运行时通过查询虚函数表的方式获得</strong>，就是 <code>虚调用</code> 。</li></ul><h2 id="虚函数-的几种-实调用-的情形"><a href="#虚函数-的几种-实调用-的情形" class="headerlink" title="虚函数 的几种 实调用 的情形"></a><code>虚函数</code> 的几种 <code>实调用</code> 的情形</h2><h3 id="不通过指针或者引用调用虚函数"><a href="#不通过指针或者引用调用虚函数" class="headerlink" title="不通过指针或者引用调用虚函数"></a>不通过指针或者引用调用虚函数</h3><ul><li><code>虚调用</code> 不能简单的理解成 “对虚函数的调用” ，因为<strong>对虚函数的调用很有可能是实调用</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;In A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;In B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="built_in">func</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述程序运行输出结果是：<code>In A</code></li><li>在函数 <code>func()</code> 中，虽然在 <code>class A</code> 中函数 <code>show()</code> 被定义为虚函数，但是由于 <code>a</code> 是类 <code>A</code> 的一个实例，而不是指向类 <code>A</code> 对象的指针或者引用，所以函数调用 <code>a.show()</code> 是实调用，<strong>函数的入口地址是在编译阶段静态决定的</strong>。</li><li>函数调用 <code>func(b)</code> 的执行过程是这样的：先由对象 <code>b</code> 通过类 <code>A</code> 的赋值构造函数，产生一个类 <code>A</code> 的对象作为函数 <code>func()</code> 的实参进入函数体。在函数体内，<code>a</code> 是一个 “纯粹” 的类 <code>A</code> 的对象，与类型 <code>B</code> 毫无关系，所以 <code>a.show()</code> 是实调用。</li></ul><h3 id="构造函数和析构函数中调用虚函数"><a href="#构造函数和析构函数中调用虚函数" class="headerlink" title="构造函数和析构函数中调用虚函数"></a>构造函数和析构函数中调用虚函数</h3><ul><li>在构造函数和析构函数中调用虚函数，对虚函数的调用实际上是实调用。这是虚函数被“实调用”的另一个例子。</li><li>构造函数中调用虚函数:<ol><li>从概念上说，在一个对象的构造函数运行完毕之前，这个对象还没有完全诞生，所以在构造函数中调用虚函数，实际上都是实调用。</li><li><strong>构造函数要先调父类的初始化函数:</strong> 因为子类会用到父类资源，比如子类获取父类的变量</li><li><strong>先初始化虚表指针在调用属性初始化和方法体:</strong> 因为构造函数会有可能调用虚函数</li><li><strong>先初始化属性在调用方法体:</strong> 方法体可能会获取属性</li></ol></li><li>析构函数中调用虚函数:<ol><li>析构时，在销毁一个对象时，先调用该对象所属类的析构函数，然后再调用其基类的析构函数。所以，<strong>在调用基类的析构函数时，派生类已经被析构了</strong>，派生类数据成员已经失效，无法动态的调用派生类的虚函数（在某些情况下会报错，例如纯虚函数）。</li><li><strong>而基类能通过虚表调用虚函数的原因是：基类在自己的析构函数中再次给自己的虚表赋值</strong>。在析构对象流程，首先释放子类的所有子类资源，在释放父类所有资源。因为子类资源被释放了，如果调用到父类时虚表没有还原父类的虚表，那么父类析构中有调用虚函数的可能会引起意外的异常。因为指向的函数是一个释放资源的子类函数。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>()&#123; <span class="built_in">show</span>(); &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123; <span class="built_in">show</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B* pb = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after new&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的执行结果是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in A</span><br><span class="line">in A</span><br><span class="line">after <span class="keyword">new</span></span><br><span class="line">in A</span><br><span class="line">after <span class="keyword">delete</span></span><br><span class="line">in A</span><br></pre></td></tr></table></figure><ul><li>在构造类 <code>B</code> 的对象时，会先调用基类 <code>A</code> 的构造函数，如果在构造函数中对 <code>show()</code> 的调用是虚调用，那么应该打印出 <code>“in B”</code> 。析构也是如此，对虚函数的调用是实调用。</li><li>因此，一般情况下，应该避免在构造函数和析构函数中调用虚函数，如果一定要这样做，必须清楚这时对虚函数的调用其实是实调用。</li></ul><h2 id="虚调用一定要借助于指针或引用来实现吗"><a href="#虚调用一定要借助于指针或引用来实现吗" class="headerlink" title="虚调用一定要借助于指针或引用来实现吗"></a>虚调用一定要借助于指针或引用来实现吗</h2><ul><li>答案是否定的。在实际应用中，绝大多数的虚调用的确是显示借助于指针或者引用来实现，但是可以通过间接的方式来实现虚调用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">callfunc</span><span class="params">()</span></span>&#123; <span class="built_in">show</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;in B&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">callfunc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序的执行结果是：<code>in B</code> 。在这个程序中，看不到一个指针或者引用，却发生了虚调用。</li><li>函数调用 <code>b.callfunc()</code> 执行的实际上是 <code>A::func()</code> 。如果在 <code>class A</code> 中去掉函数 <code>show()</code> 前面的关键字 <code>virtual</code>，那么程序的输出结果是：<code>in A</code> 。也就是说，在函数 <code>callfunc()</code> 中，函数调用 <code>show()</code> 是一个虚调用，它是在运行时才决定使用派生类中的虚函数还是使用基类中的虚函数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 的几种类型转换</title>
      <link href="//Eight-Part_Essay/C++/Type_Conversion/"/>
      <url>//Eight-Part_Essay/C++/Type_Conversion/</url>
      
        <content type="html"><![CDATA[<h2 id="C-的几种类型转换"><a href="#C-的几种类型转换" class="headerlink" title="C++ 的几种类型转换"></a>C++ 的几种类型转换</h2><ul><li>在 C 语言中，我们大多数是用 <code>(type_name) expression</code> 这种方式来做强制类型转换，但是在 C++ 中，更推荐使用四个转换操作符来实现显式类型转换：<ol><li><strong>static_cast</strong></li><li><strong>dynamic_cast</strong></li><li><strong>const_cast</strong></li><li><strong>reinterpret_cast</strong></li></ol></li></ul><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><ul><li>用法: <code>static_cast &lt;new_type&gt; (expression)</code> 。其实 <code>static_cast</code> 和 C 语言 <code>()</code> 做强制类型转换基本是等价的。主要用于以下场景:</li></ul><h4 id="基本类型之间的转换"><a href="#基本类型之间的转换" class="headerlink" title="基本类型之间的转换"></a>基本类型之间的转换</h4><ul><li>将一个基本类型转换为另一个基本类型，例如将整数转换为浮点数或将字符转换为整数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(a); <span class="comment">// 将整数a转换为双精度浮点数b</span></span><br></pre></td></tr></table></figure><h4 id="指针类型之间的转换"><a href="#指针类型之间的转换" class="headerlink" title="指针类型之间的转换"></a>指针类型之间的转换</h4><ul><li>将一个指针类型转换为另一个指针类型，尤其是在类层次结构中从基类指针转换为派生类指针。<strong>这种转换不执行运行时类型检查，可能不安全，要自己保证指针确实可以互相转换</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* base_ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derived_ptr = <span class="built_in">static_cast</span>&lt;Derived*&gt;(base_ptr); <span class="comment">// 将基类指针base_ptr转换为派生类指针derived_ptr</span></span><br></pre></td></tr></table></figure><h4 id="引用类型之间的转换"><a href="#引用类型之间的转换" class="headerlink" title="引用类型之间的转换"></a>引用类型之间的转换</h4><ul><li>类似于指针类型之间的转换，可以将一个引用类型转换为另一个引用类型。<strong>在这种情况下，也应注意安全性</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived derived_obj;</span><br><span class="line">Base&amp; base_ref = derived_obj;</span><br><span class="line">Derived&amp; derived_ref = <span class="built_in">static_cast</span>&lt;Derived&amp;&gt;(base_ref); <span class="comment">// 将基类引用base_ref转换为派生类引用derived_ref</span></span><br></pre></td></tr></table></figure><ul><li><code>static_cast</code> <strong>在编译时执行类型转换</strong>，在进行指针或引用类型转换时，需要自己保证合法性。如果想要运行时类型检查，可以使用 <code>dynamic_cast</code> 进行安全的向下类型转换。</li></ul><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><ul><li>用法: <code>dynamic_cast &lt;new_type&gt; (expression)</code> 。<code>dynamic_cast</code> 在 C++ 中主要应用于父子类层次结构中的安全类型转换。它在运行时执行类型检查，因此相比于 <code>static_cast</code> ，它更加安全。<code>dynamic_cast</code> 的主要应用场景：</li></ul><h4 id="向下类型转换"><a href="#向下类型转换" class="headerlink" title="向下类型转换"></a>向下类型转换</h4><ul><li>当需要将基类指针或引用转换为派生类指针或引用时，<code>dynamic_cast</code> 可以确保类型兼容性。如果转换失败，<code>dynamic_cast</code> 将<strong>返回空指针（对于指针类型）或抛出异常（对于引用类型）</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; <span class="type">int</span> a; &#125;;</span><br><span class="line"></span><br><span class="line">Base* base_ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derived_ptr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base_ptr); <span class="comment">// 将基类指针base_ptr转换为派生类指针derived_ptr，如果类型兼容，则成功</span></span><br></pre></td></tr></table></figure><h4 id="用于多态类型检查"><a href="#用于多态类型检查" class="headerlink" title="用于多态类型检查"></a>用于多态类型检查</h4><ul><li>处理多态对象时，<code>dynamic_cast</code> 可以用来确定对象的实际类型，例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123; <span class="keyword">public</span>: <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123; <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123; <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">meow</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">Animal* animal_ptr = <span class="comment">/* ... */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试将Animal指针转换为Dog指针</span></span><br><span class="line">Dog* dog_ptr = <span class="built_in">dynamic_cast</span>&lt;Dog*&gt;(animal_ptr);</span><br><span class="line"><span class="keyword">if</span> (dog_ptr) </span><br><span class="line">&#123;</span><br><span class="line">    dog_ptr-&gt;<span class="built_in">bark</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试将Animal指针转换为Cat指针</span></span><br><span class="line">Cat* cat_ptr = <span class="built_in">dynamic_cast</span>&lt;Cat*&gt;(animal_ptr);</span><br><span class="line"><span class="keyword">if</span> (cat_ptr) </span><br><span class="line">&#123;</span><br><span class="line">    cat_ptr-&gt;<span class="built_in">meow</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>另外，要使 <code>dynamic_cast</code> 有效，<strong>基类至少需要一个虚函数</strong>。因为，<code>dynamic_cast</code> <strong>只有在基类存在虚函数(虚函数表)的情况下才有可能将基类指针转化为子类</strong>。</li></ul><h4 id="dynamic-cast-底层原理"><a href="#dynamic-cast-底层原理" class="headerlink" title="dynamic_cast 底层原理"></a>dynamic_cast 底层原理</h4><ul><li><code>dynamic_cast</code> 的底层原理依赖于<strong>运行时类型信息（RTTI, Runtime Type Information）</strong>。C++ 编译器在编译时为支持多态的类生成RTTI，它包含了类的类型信息和类层次结构。</li><li>我们都知道当使用虚函数时，编译器会为每个类生成一个虚函数表（vtable），并在其中存储指向虚函数的指针。伴随虚函数表的还有<strong>RTTI(运行时类型信息)</strong>，这些辅助的信息可以用来帮助我们运行时识别对象的类型信息。</li><li>《深度探索C++对象模型》中有个例子：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">float</span> xval);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">PointCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> _x;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _point_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="C++对象模型.png" alt="C++对象模型" style="zoom:50%;"></p><ul><li>首先，每个多态对象都有一个指向其 <code>vtable</code> 的指针，称为 <code>vptr</code> 。<code>RTTI</code>（就是上面图中的 <code>type_info</code> 结构）通常与 <code>vtable</code> 关联。<code>dynamic_cast</code> 就是利用 <code>RTTI</code> 来执行运行时类型检查和安全类型转换。</li><li>以下是 <code>dynamic_cast</code> 的工作原理的简化描述：<ol><li>首先，<code>dynamic_cast</code> 通过查询对象的 <code>vptr</code> 来获取其 <code>RTTI</code>（这也是为什么 <code>dynamic_cast</code> 要求对象有虚函数）</li><li>然后，<code>dynamic_cast</code> 比较请求的目标类型与从 <code>RTTI</code> 获得的实际类型。如果目标类型是实际类型或其基类，则转换成功。</li><li>如果目标类型是派生类，<code>dynamic_cast</code> 会检查<strong>类层次结构</strong>，以确定转换是否合法。如果在<strong>类层次结构</strong>中找到了目标类型，则转换成功；否则，转换失败。</li><li><strong>转换成功时，<code>dynamic_cast</code> 返回转换后的指针或引用</strong>。</li><li><strong>转换失败时，对于指针类型，<code>dynamic_cast</code> 返回空指针；对于引用类型，它会抛出一个 <code>std::bad_cast</code> 异常</strong>。</li></ol></li><li>因为 <code>dynamic_cast</code> 依赖于运行时类型信息，<strong>它的性能可能低于其他类型转换操作</strong>（如 <code>static_cast</code> ），<strong><code>static_cast</code> 是编译器静态转换，编译时期就完成了</strong>。</li></ul><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><ul><li>用法: <code>const_cast &lt;new_type&gt; (expression)</code>, <strong><code>new_type</code> 必须是一个指针、引用或者指向对象类型成员的指针</strong>。</li></ul><h4 id="修改const对象"><a href="#修改const对象" class="headerlink" title="修改const对象"></a>修改const对象</h4><ul><li>当需要修改 <code>const</code> 对象时，可以使用 <code>const_cast</code> 来删除 <code>const</code> 属性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* mutable_ptr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;a); <span class="comment">// 删除 const 属性，使得可以修改a的值</span></span><br><span class="line">*mutable_ptr = <span class="number">43</span>; <span class="comment">// 修改a的值</span></span><br></pre></td></tr></table></figure><h5 id="修改局部变量"><a href="#修改局部变量" class="headerlink" title="修改局部变量"></a>修改局部变量</h5><ul><li>程序能正常运行，且常量被修改了，但是有一个问题：输出 <code>a</code> 的值和 <code>*mutable_ptr</code> 的值并不相同，<code>a</code> 的值还是 <code>42</code> ，而 <code>*mutable_ptr</code> 的值是 <code>43</code> , 而且 <code>mutable_ptr</code> 确实指向 <code>a</code> 所在的地址空间。</li><li>这是什么原因呢？难道一个地址空间可以存储不同的俩个值？当然不能。这就是 C++ 中的<strong>常量折叠</strong>：<code>const</code> 变量（即常量）值放在编译器的符号表中，计算时编译器直接从表中取值，省去了访问内存的时间，这是编译器进行的优化。<code>a</code> 是 <code>const</code> 变量，编译器对 <code>a</code> 在预处理的时候就进行了替换。编译器只对 <code>const</code> 变量的值读取一次。所以打印的是 <code>42</code> 。<code>a</code> 实际存储的值被指针 <code>mutable_ptr</code> 所改变。但是为什么能改变呢，从其存储地址可以看出来，其存储在堆栈中。</li></ul><h5 id="修改全局变量"><a href="#修改全局变量" class="headerlink" title="修改全局变量"></a>修改全局变量</h5><ul><li>程序编译通过，但运行时错误。编译器提示 <code>a</code> 存储的空间不可写，也就是没有写权限，不能修改其值。原因是 <code>a</code> 是全局变量，全局变量存储在静态存储区，且只有可读属性，无法修改其值。</li></ul><h5 id="使用-volatile-关键字"><a href="#使用-volatile-关键字" class="headerlink" title="使用 volatile 关键字"></a>使用 volatile 关键字</h5><ul><li><a href="/Eight-Part_Essay/C++/Broken_Jade_Beads/">碎玉零珠 —— C++</a> 中有详细介绍，就不赘述了。</li></ul><h4 id="const对象调用非const成员函数"><a href="#const对象调用非const成员函数" class="headerlink" title="const对象调用非const成员函数"></a>const对象调用非const成员函数</h4><ul><li>当需要使用 <code>const</code> 对象调用非 <code>const</code> 成员函数时，可以使用 <code>const_cast</code> 删除对象的 <code>const</code> 属性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">non_const_function</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> MyClass my_const_obj;</span><br><span class="line">MyClass* mutable_obj_ptr = <span class="built_in">const_cast</span>&lt;MyClass*&gt;(&amp;my_const_obj); <span class="comment">// 删除const属性，使得可以调用非const成员函数</span></span><br><span class="line">mutable_obj_ptr-&gt;<span class="built_in">non_const_function</span>(); <span class="comment">// 调用非const成员函数</span></span><br></pre></td></tr></table></figure><ul><li>不过上述行为都不是很安全，可能导致未定义的行为，因此应谨慎使用。</li></ul><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><ul><li>用法: <code>reinterpret_cast &lt;new_type&gt; (expression)</code>, <code>reinterpret_cast</code> 用于在不同类型之间进行低级别的转换。</li><li>首先从英文字面的意思理解，<code>interpret</code> 是 <code>“解释，诠释”</code> 的意思，加上前缀 <code>“re”</code> ，就是 <code>“重新诠释”</code> 的意思；<code>cast</code> 在这里可以翻译成 <code>“转型”</code>（在侯捷大大翻译的《深度探索C++对象模型》、《Effective C++（第三版）》中，<code>cast</code> 都被翻译成了转型），这样整个词顺下来就是 <code>“重新诠释的转型”</code> 。<strong>它仅仅是重新解释底层比特（也就是对指针所指的那片比特位换个类型做解释），而不进行任何类型检查</strong>。因此，<code>reinterpret_cast</code> 可能导致未定义的行为，应谨慎使用。</li></ul><h4 id="reinterpret-cast-底层原理"><a href="#reinterpret-cast-底层原理" class="headerlink" title="reinterpret_cast 底层原理"></a>reinterpret_cast 底层原理</h4><ul><li>一个指向字符串的指针是如何地与一个指向整数的指针或一个指向其他自定义类型对象的指针有所不同呢？从内存需求的观点来说，没有什么不同！它们三个都需要足够的内存（并且是相同大小的内存）来放置一个机器地址。指向不同类型的各指针之间的差异，既不在其指针表示法不同，也不在其内容（代表一个地址）不同，而是在其所寻址出来的对象类型不同。也就是说，指针类型会教导编译器如何解释某个特定地址中的内存内容及其大小。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0x00636261</span>; <span class="comment">//用16进制表示32位int，0x61是字符&#x27;a&#x27;的ASCII码</span></span><br><span class="line">    <span class="type">int</span> * pnum = &amp;num;</span><br><span class="line">    <span class="type">char</span> * pstr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(pnum);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pnum指针的值: &quot;</span> &lt;&lt; pnum &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pstr指针的值: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(pstr) &lt;&lt; endl; <span class="comment">//直接输出pstr会输出其指向的字符串，这里的类型转换是为了保证输出pstr的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pnum指向的内容: &quot;</span> &lt;&lt; hex &lt;&lt; *pnum &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pstr指向的内容: &quot;</span> &lt;&lt; pstr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：</span></span><br><span class="line"><span class="comment">        pnum指针的值: 0x61fe0c</span></span><br><span class="line"><span class="comment">        pstr指针的值: 0x61fe0c</span></span><br><span class="line"><span class="comment">        pnum指向的内容: 636261</span></span><br><span class="line"><span class="comment">        pstr指向的内容: abc</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>reinterpret_cast</code> 运算符把 <code>pnum</code> 从 <code>int*</code> 转变成 <code>char*</code> 类型并用于初始化 <code>pstr</code> 后，<code>pstr</code> 也指向 <code>num</code> 的内存区域，但是由于 <code>pstr</code> 是 <code>char*</code> 类型的，通过 <code>pstr</code> 读写 <code>num</code> 内存区域将不再按照整型变量的规则，而是按照 <code>char</code> 型变量规则。一个 <code>char</code> 型变量占用一个 <code>Byte</code> ，对 <code>pstr</code> 解引用得到的将是一个字符，也就是 <code>a</code> 。而在使用输出流输出 <code>pstr</code> 时，将输出 <code>pstr</code> 指向的内存区域的字符，那 <code>pstr</code> 指向的是一个的字符，那为什么输出三个字符呢？这是由于在输出 <code>char*</code> 指针时，输出流会把它当做输出一个字符串来处理，直至遇到 <code>\0</code> 才表示字符串结束。对代码稍做改动，就会得到不一样的输出结果，例如将 <code>num</code> 的值改为 <code>0x63006261</code> , 输出的字符串就变为 <code>ab</code> 。</li><li>上面的例子融合了一些巧妙的设计，我们在pstr指向的内存区域中故意地设置了结束符 <code>\0</code> 。假如将 <code>num</code> 的值改为 <code>0x64636261</code> ，运行结果会是怎样的呢？</li></ul><p><img src="地址.png" alt="内存示意图" style="zoom:100%;"><br><img src="运行结果.png" alt="运行结果" style="zoom:100%;"></p><ul><li>参考上面的内存示意图，思考一下为什么在输出”abcd”之后又输出了6个字符才结束。</li></ul><h4 id="指针类型间的转换"><a href="#指针类型间的转换" class="headerlink" title="指针类型间的转换"></a>指针类型间的转换</h4><ul><li>在某些情况下，需要在不同指针类型之间进行转换，如将一个 <code>int</code> 指针转换为 <code>char</code> 指针。这在 C 语言中用的非常多，C语言中就是直接使用 <code>()</code> 进行强制类型转换</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* int_ptr = &amp;a;</span><br><span class="line"><span class="type">char</span>* char_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(int_ptr); <span class="comment">// 将int指针转换为char指针</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 八股文 - C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 模板相关问题</title>
      <link href="//Eight-Part_Essay/C++/Template_Problem/"/>
      <url>//Eight-Part_Essay/C++/Template_Problem/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么模板声明定义不能分离"><a href="#为什么模板声明定义不能分离" class="headerlink" title="为什么模板声明定义不能分离?"></a>为什么模板声明定义不能分离?</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>模板函数一般不能声明定义分开，但是普通函数函数就可以，为什么呢？那就要先介绍一下在软件开发过程中，从源代码到可执行程序，通常会经历预处理、编译、汇编、链接的这四个主要步骤。</li></ul><ol><li><strong>预处理 ( Preprocessing )</strong>：<ul><li>任务：预处理器的任务是处理源代码中的预处理指令，如宏定义（#define）、文件包含（#include）、条件编译（#ifdef、#ifndef、#endif等）指令。它会删除所有注释，展开所有宏定义，处理条件编译指令，并插入包含文件的内容。</li><li>生成文件：预处理后的文件通常以 .i 或 .ii 结尾（在C/C++中），这是预处理后的文本文件，仍然保持高级语言的形式。</li></ul></li><li><strong>编译 ( Compilation )</strong>：<ul><li>任务：编译器将预处理后的源代码转换成汇编语言。这个过程包括词法分析、语法分析、语义分析、中间代码生成、代码优化等步骤。编译器检查源代码中的错误，如语法错误、类型错误等，并将源代码转换成汇编指令。</li><li>生成文件：编译阶段生成的文件通常称为目标文件（Object File），以 .s结尾。这个文件包含机器代码，但是它还不能直接执行（计算机无法识别），因为它可能包含未解析的符号引用。</li></ul></li><li><strong>汇编 ( Assembly )</strong>：<ul><li>任务：汇编器将汇编语言转换成机器语言。它将汇编指令转换成对应的二进制代码，并处理与特定硬件平台相关的指令。</li><li>生成文件：汇编阶段生成的是机器码，它通常被直接存储在目标文件中，所以这个步骤可能不会生成新的文件，而是更新之前编译阶段生成的 .o 或 .obj 文件。</li></ul></li><li><strong>链接 ( Linking )</strong>：<ul><li>任务：链接器将一个或多个目标文件以及所需的库文件组合成一个完整的可执行程序。这个过程包括地址和空间分配、符号决议、重定位等。链接器确保所有外部引用的函数和变量都有正确的地址，并解决不同目标文件之间的依赖关系。</li><li>生成文件：链接阶段生成的最终文件是可执行文件，在Unix/Linux系统中通常以 .out 或 .exe 结尾，在Windows系统中通常以 .exe 结尾。</li></ul></li></ol><h3 id="普通函数为什么支持分离定义"><a href="#普通函数为什么支持分离定义" class="headerlink" title="普通函数为什么支持分离定义"></a>普通函数为什么支持分离定义</h3><ol><li>编译过程<ul><li><strong>编译时只看声明：</strong> 当编译器编译一个源文件（比如 main.cpp）时，它只需要知道函数的声明，不需要知道函数的实现。因此，编译器可以生成对 myFunction 的调用指令，而无需查看 my_function.cpp 中的实际代码。</li></ul></li><li>链接过程<ul><li><strong>符号引用：</strong> 编译器在编译源文件时，会为函数调用生成一个符号引用（通常是函数名）。这个符号引用将被放在生成的目标文件（.o 或 .obj 文件）中。</li><li><strong>符号定义：</strong> 链接器在链接阶段会查找这些符号引用对应的符号定义。如果 myFunction 的定义在 my_function.cpp 中，链接器会在链接时找到这个定义，并将调用指令与实际函数代码连接起来。</li></ul></li></ol><ul><li><strong>而正常函数编译阶段只需要看到声明；链接时，才回去寻找定义</strong>！这样可以大大提高编译效率！</li></ul><h3 id="为什么模板函数不支持分离"><a href="#为什么模板函数不支持分离" class="headerlink" title="为什么模板函数不支持分离"></a>为什么模板函数不支持分离</h3><ul><li>这主要与模板函数的编译、链接过程与普通函数的差异性有关。</li></ul><ol><li><strong>实例化发生在编译时：</strong> 对于模板函数，<strong>实例化是在编译时（也就是头文件展开之后）进行的，而不是在链接时</strong>。编译器需要模板函数的定义来生成特定类型的函数实例。</li><li><strong>实例化的多样性：</strong> 由于模板可以针对任意类型进行实例化，编译器无法在编译时预先知道所有可能的实例化。因此，它不能像普通函数那样在链接时查找定义。</li><li><strong>编译器优化：</strong> 编译器在编译时对模板函数进行实例化，允许它针对特定类型进行优化。如果模板函数的定义在 .cpp 文件中，编译器在编译时看不到这些定义，因此无法进行优化。</li></ol><ul><li>通俗地说</li></ul><ol><li>模板函数是一个模板，只有实例化时，才能得到函数的定义。假如我们将声明放在头文件，将定义放在源文件。这就会出现链接错误。</li><li>对于编译器而言，它<strong>需要在头文件展开之后（也就是编译阶段）就需要找到模板函数的定义</strong>，然后才能在链接阶段进行绑定，完成程序。如果找不到模板函数的定义，就可能出现编译阶段的错误，但是最终还是体现在了链接部分。</li></ol><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><ol><li><p><strong>显式实例化</strong></p><ul><li><p>将模板函数在源文件中定义之后，需要在源文件额外进行模板函数的显式实例化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化模板函数swap用于int类型</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b);</span><br></pre></td></tr></table></figure></li><li><p>编译器就只会为 int 类型的 swap 函数生成代码，而不会为其他类型生成。这可以减少编译时间和可执行文件的大小。</p></li><li><p>当我们调用 swap 函数时，如果我们只交换int类型的变量，编译器就会使用上面显式实例化的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">swap</span>(x, y); <span class="comment">// 使用显式实例化的swap&lt;int&gt;函数</span></span><br></pre></td></tr></table></figure></li><li><p>显式实例化之后，意味着实例化了模板，<strong>确保了编译器在编译阶段生成特定类型的函数代码，从而使得链接器在链接阶段能够找到这些实例化的函数实现</strong>。显式实例化在编译阶段起到了模板函数定义的作用。</p></li><li>在显式实例化的情况下，不需要模板函数的定义在编译时可见，因为编译器已经根据显式实例化指令（在另一个.cpp文件）创建了函数的实现。这与普通函数不同，普通函数需要在链接时找到其定义（ <strong>显式实例化之后，就相当于生成了一份模板函数定义的代码（对应着特定的类型），在链接阶段就可以找到定义）</strong>。</li></ul></li><li><p><strong>定义在同一个头文件中</strong></p><ul><li><p>在头文件末尾直接包含源文件（需重命名为 .hpp 或 .tpp），确保编译器能看到定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stack.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Stack</span> &#123; <span class="comment">/* 声明 */</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Stack.tpp&quot;</span> <span class="comment">// 包含模板实现</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack.tpp（原 Stack.cpp）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">const</span> T&amp; value) &#123; <span class="comment">/* 实现 */</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>优点：代码组织清晰，符合传统头文件/源文件分离习惯。</p></li><li>缺点：可能暴露实现细节，且需避免重复包含。</li></ul></li></ol><h3 id="模板的优缺点"><a href="#模板的优缺点" class="headerlink" title="模板的优缺点"></a>模板的优缺点</h3><ul><li>优点：<ol><li>模板复用了代码，节省资源，更快的选代开发，C++的标准模板库(STL)因此而产生</li><li>增强了代码的灵活性</li></ol></li><li>缺点：<ol><li>模板会导致代码膨胀问题，也会导致编译时间变长（每种实例化都会产生额外的函数代码）</li><li>出现模板编译错误时，错误信息非常凌乱，不易定位错误</li></ol></li></ul><h2 id="模板特化、偏特化"><a href="#模板特化、偏特化" class="headerlink" title="模板特化、偏特化"></a>模板特化、偏特化</h2><h2 id="模板在编译时生成的代码是否会相同，生成的相同的代码如何处理"><a href="#模板在编译时生成的代码是否会相同，生成的相同的代码如何处理" class="headerlink" title="模板在编译时生成的代码是否会相同，生成的相同的代码如何处理"></a>模板在编译时生成的代码是否会相同，生成的相同的代码如何处理</h2>]]></content>
      
      
      <categories>
          
          <category> 八股文 - C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="//Eight-Part_Essay/C++/Sorting_Algorithm/"/>
      <url>//Eight-Part_Essay/C++/Sorting_Algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="各种排序算法的原理和时间复杂度"><a href="#各种排序算法的原理和时间复杂度" class="headerlink" title="各种排序算法的原理和时间复杂度"></a>各种排序算法的原理和时间复杂度</h2><ul><li><strong>快速排序</strong>：一轮划分，选择一个基准值，小于该基准值的元素放到左边，大于的放在右边，此时该基准值在整个序列中的位置就确定了，接着递归地对左边子序列和右边子序列进行划分。时间复杂度O(nlogn)，最坏的时间复杂度是O(n^2)。<strong>需要排序的对象越有序，快速排序的退化程度越高，即时间复杂度越趋向于O(n ^ 2)</strong>。通过随机选择枢轴，可以有效地避免这种情况。随机选择使得每次分区都有较大概率是平衡的，从而保持了快速排序的平均时间复杂度 O(n * logn)；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pivot = <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>) + left;</span><br><span class="line">    <span class="built_in">swap</span>(nums[pivot], nums[right]);</span><br><span class="line"></span><br><span class="line">    pivot = nums[right];</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt; right; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i++], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[i], nums[right]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">QuickSort</span>(nums, left, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="built_in">SortArray</span>(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>堆排序</strong>：利用完全二叉树性质构造的一个一维数组，用数组下标代表结点，则一个结点的左孩子下标为2i+1,右孩子为2i+2，一个结点的父节点为(i-1)/2。堆排序的思想就是，构造一个最大堆或者最小堆，以最大堆为例，那么最大的值就是根节点，把这个最大值和最后一个结点交换，然后在从前n-1个结点中构造一个最大堆，再重复上述的操作，即每次将现有序列的最大值放在现有数组的最后一位，最后就会形成一个有序数组；求升序用最大堆，降序用最小堆。时间复杂度O(nlogn)；</li><li><strong>冒泡排序</strong>：从前往后两两比较，逆序则交换，不断重复直到有序；时间复杂度O(n^2)，最好情况O(n)；</li><li><strong>插入排序</strong>：类似打牌，从第二个元素开始，把每个元素插入前面有序的序列中；时间复杂度O(n^2)，最好情况O(n)；</li><li><strong>选择排序</strong>：每次选择待排序列中的最小值和未排序列中的首元素交换；时间复杂度O(n^2);</li><li><strong>归并排序</strong>：将整个序列划分成最小的&gt;=2的等长序列，排序后再合并，再排序再合并，最后合成一个完整序列。时间复杂度O(nlogn)。</li><li><strong>希尔排序</strong>：是插入排序的改进版，取一个步长划分为多个子序列进行排序，再合并（如135一个序列，246一个序列），时间复杂度O(n1.3)，最好O(n)，最坏O(n^2)；</li><li><strong>桶排序</strong>：将数组分到有限数量的桶里。每个桶再个别排序，最后依次把各个桶中的记录列出来记得到有序序列。桶排序的平均时间复杂度为线性的O(N+C)，其中C = N * (logN - logM)，M为桶的数量。最好的情况下为O(N)。</li></ul><div class="table-container"><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>最好时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>插入排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(n log n)</td><td>O(n²)</td><td>O(n log n)</td><td>O(log n)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>希尔排序</td><td>O(n log n)</td><td>O(n²)</td><td>O(n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n)</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(nk)</td><td>O(nk)</td><td>O(nk)</td><td>O(n + k)</td><td>稳定</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 八股文 - C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="//Eight-Part_Essay/C++/Smart_Pointer/"/>
      <url>//Eight-Part_Essay/C++/Smart_Pointer/</url>
      
        <content type="html"><![CDATA[<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><ul><li>独占资源所有权的指针。由于没有引用计数，因此性能较好。</li><li>离开 <code>unique_ptr</code> 对象的作用域时，会自动释放资源。</li><li><code>unique_ptr</code> 本质是一个类，将复制构造函数和赋值构造函数声明为 <code>delete</code> 就可以实现独占式，<br>只允许移动构造和移动赋值。<code>unique_ptr</code> 所持有的对象只能通过 <code>转移语义(move)</code> 将所有权转移<br>到另外一个 <code>unique_ptr</code> 。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义实现 unique_ptr</span></span><br><span class="line"><span class="built_in">UniquePtr</span>(UniquePtr&lt;T&gt; <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">UniquePtr &amp; <span class="keyword">operator</span>=(UniquePtr&lt;T&gt; <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; uptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 离开 uptr 的作用域的时候自动释放内存</span></span><br></pre></td></tr></table></figure><ul><li><code>std::unique_ptr</code> 是 <code>move-only</code> 的。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; uptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; uptr1 = uptr;  <span class="comment">// 编译错误，std::unique_ptr&lt;T&gt; 是 move-only 的</span></span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; uptr2 = std::<span class="built_in">move</span>(uptr);</span><br><span class="line"><span class="built_in">assert</span>(uptr == <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><ul><li><code>std::unique_ptr</code> 可以指向一个数组。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>[]&gt; uptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">    uptr[i] = i * i;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; uptr[i] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><ul><li><code>std::shared_ptr</code> 其实就是对资源做引用计数——当引用计数为 <code>0</code> 的时候，自动释放资源。</li></ul><h3 id="C-智能指针的实现（手撕-shared-ptr）"><a href="#C-智能指针的实现（手撕-shared-ptr）" class="headerlink" title="C++ 智能指针的实现（手撕 shared_ptr）"></a>C++ 智能指针的实现（手撕 shared_ptr）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">    <span class="type">int</span>* ref_count;</span><br><span class="line">    <span class="comment">// 释放方法为内置方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ref_count) </span><br><span class="line">        &#123;</span><br><span class="line">            --(*ref_count);</span><br><span class="line">            <span class="keyword">if</span> (*ref_count == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> ref_count;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            ref_count = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// shared_ptr</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">ref_count</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 用初始指针,new</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>(T* p) : <span class="built_in">ptr</span>(p), <span class="built_in">ref_count</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&amp; other) : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">ref_count</span>(other.ref_count) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ref_count) &#123; ++(*ref_count); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() &#123; <span class="built_in">release</span>(); &#125;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&amp; other) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            ref_count = other.ref_count;</span><br><span class="line">            <span class="keyword">if</span> (ref_count) &#123; ++(*ref_count); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ref_count ? *ref_count : <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123; <span class="built_in">release</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">        ptr = p;</span><br><span class="line">        ref_count = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> * () <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt; () <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="std-shared-ptr-的实现原理"><a href="#std-shared-ptr-的实现原理" class="headerlink" title="std::shared_ptr 的实现原理"></a>std::shared_ptr 的实现原理</h3><ul><li><code>shared_ptr</code> 需要维护的信息有两部分：<ol><li>指向共享资源的指针</li><li>引用计数等共享资源的控制信息——实现上是维护一个指向控制信息的指针。</li></ol></li><li>所以，<code>shared_ptr</code> 对象<strong>需要保存两个指针（shared_ptr 大小为 16 ）</strong>。<code>shared_ptr</code> 的 <code>deleter</code> 是保存在控制信息中，所以，是否有自定义 <code>deleter</code> 不影响 <code>shared_ptr</code> 对象的大小。</li><li>当我们创建一个 shared_ptr 时，其实现一般如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">sptr1</span><span class="params">(<span class="keyword">new</span> T)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="智能指针1.jpg" alt="智能指针1" style="zoom:100%;"></p><ul><li>复制一个 shared_ptr：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;T&gt; sptr2 = sptr1;</span><br></pre></td></tr></table></figure><p><img src="智能指针2.jpg" alt="智能指针2" style="zoom:100%;"></p><ul><li>为什么控制信息和每个 <code>shared_ptr</code> 对象都需要保存指向共享资源的指针？可不可以去掉 <code>shared_ptr</code> 对象中指向共享资源的指针，以节省内存开销？</li><li>答案是：不能。 因为 <code>shared_ptr</code> 对象中的指针指向的对象不一定和控制块中的指针指向的对象一样。</li><li>来看一个例子:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fruit</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> juice;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vegetable</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fiber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tomato</span> : <span class="keyword">public</span> Fruit, Vegetable </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sauce;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 由于继承的存在，shared_ptr 可能指向基类对象</span></span><br><span class="line">std::shared_ptr&lt;Tomato&gt; tomato = std::<span class="built_in">make_shared</span>&lt;Tomato&gt;();</span><br><span class="line">std::shared_ptr&lt;Fruit&gt; fruit = tomato;</span><br><span class="line">std::shared_ptr&lt;Vegetable&gt; vegetable = tomato;</span><br></pre></td></tr></table></figure><p><img src="智能指针3.jpg" alt="智能指针3" style="zoom:100%;"></p><ul><li>另外，<code>std::shared_ptr</code> 支持 <code>aliasing constructor</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y &gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">( <span class="type">const</span> shared_ptr&lt;Y&gt;&amp; r, element_type* ptr )</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>Aliasing Constructor</code> : 简单说就是构造出来的 <code>shared_ptr</code> 对象和参数 <code>r</code> 指向同一个控制块（会影响 <code>r</code> 指向的资源的生命周期），但是指向共享资源的指针是参数 <code>ptr</code> 。看下面这个例子。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">GetSPtr</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> elts = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::shared_ptr&lt;Vec&gt; pvec = std::<span class="built_in">make_shared</span>&lt;Vec&gt;(elts);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(pvec, &amp;(*pvec)[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sptr = <span class="built_in">GetSPtr</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-2</span>; i &lt; <span class="number">3</span>; ++i) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sptr.<span class="built_in">get</span>()[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="智能指针4.jpg" alt="智能指针4" style="zoom:100%;"></p><ul><li>看上面的例子，使用 <code>std::shared_ptr</code> 时，会涉及两次内存分配：一次分配共享资源对象；一次分配控制块。C++ 标准库提供了 <code>std::make_shared</code> 函数来创建一个 <code>shared_ptr</code> 对象，只需要一次内存分配。</li></ul><p><img src="智能指针5.jpg" alt="智能指针5" style="zoom:100%;"></p><ul><li>这种情况下，不用通过控制块中的指针，我们也能知道共享资源的位置——这个指针也可以省略掉。</li></ul><p><img src="智能指针6.jpg" alt="智能指针6" style="zoom:100%;"></p><h3 id="shared-ptr-是线程安全的吗"><a href="#shared-ptr-是线程安全的吗" class="headerlink" title="shared_ptr 是线程安全的吗"></a>shared_ptr 是线程安全的吗</h3><ul><li><strong><code>shared_ptr</code> 在 C++ 中是部分线程安全的</strong>, 这意味着它不是在所有情况下都是安全的</li></ul><h4 id="线程安全的部分"><a href="#线程安全的部分" class="headerlink" title="线程安全的部分"></a>线程安全的部分</h4><ul><li><strong><code>std::shared_ptr</code> 的引用计数（即管理对象的共享所有权的计数）是线程安全的</strong>。因为<code>std::shared_ptr</code> 的内部引用计数是原子的，这意味着多个线程可以安全地对同一个 <code>std::shared_ptr</code> 对象进行引用计数的操作（如 <code>shared_ptr</code> 的拷贝构造和赋值）。这些操作不会导致数据竞争。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">10000</span>;</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp_arr1</span>(N);</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp_arr2</span>(N);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_count</span><span class="params">(std::vector&lt;std::shared_ptr&lt;<span class="type">int</span>&gt;&gt;&amp; sp_arr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) </span><br><span class="line">    &#123;        </span><br><span class="line">        sp_arr[i] = p;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment_count, std::ref(sp_arr1))</span></span>;    </span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment_count, std::ref(sp_arr2))</span></span>;    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();    </span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();    </span><br><span class="line">    std::cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// always 20001</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>初始引用计数</strong>：<code>p</code> 初始时有一个引用计数，因为它本身就是一个 <code>std::shared_ptr</code> 。因此，初始的引用计数是 <code>1</code> 。</li><li><strong>线程 <code>t1</code> 和 <code>t2</code> 的操作</strong>：每个线程将 <code>p</code> 赋值给一个包含 <code>10000</code> 个元素的向量中的每个元素。每次赋值操作都会增加 <code>p</code> 的引用计数。由于有两个线程，每个线程都会增加 <code>10000</code> 次引用计数。因此，总的引用计数增加量是 <code>10000 + 10000 = 20000</code></li><li><strong>最终引用计数</strong>：初始引用计数 <code>1</code> 加上两个线程增加的引用计数 <code>20000</code>，总引用计数为 <code>1 + 20000 = 20001</code></li><li>这里的关键在于<strong>每次赋值操作都会原子地增加引用计数</strong>。因此，即使两个线程同时执行 <code>sp_arr[i] = p;</code> ，也不会导致数据竞争或未定义行为。</li></ul><h4 id="线程不安全的部分"><a href="#线程不安全的部分" class="headerlink" title="线程不安全的部分"></a>线程不安全的部分</h4><h5 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h5><ul><li>尽管 <code>std::shared_ptr</code> 的引用计数是线程安全的，但对所管理对象的访问并不是线程安全的。如果多个线程同时访问同一个 <code>shared_ptr</code> 管理的对象，并且至少有一个线程在修改该对象，那么就需要额外的同步机制（如互斥锁）来确保线程安全。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_memory</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) </span><br><span class="line">    &#123;        </span><br><span class="line">        (*p1)++;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(modify_memory)</span></span>;    </span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(modify_memory)</span></span>;    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();    </span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final value of p: &quot;</span> &lt;&lt; *p1 &lt;&lt; std::endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面的代码运行，输出的结果不是预想的 <code>20000</code> ，每次运行输出的结果都会发生变化。因此同时修改 <code>shared_ptr</code> 指向的对象不是线程安全的。</li></ul><h5 id="直接修改-shared-ptr-对象本身的指向"><a href="#直接修改-shared-ptr-对象本身的指向" class="headerlink" title="直接修改 shared_ptr 对象本身的指向"></a>直接修改 shared_ptr 对象本身的指向</h5><ul><li>如果多个线程同时修改同一个 <code>std::shared_ptr</code> 对象的指向（例如，使用赋值操作或重置操作），这将导致<strong>数据竞争</strong>。</li><li>数据竞争可能导致以下问题：<ol><li><strong>引用计数的损坏</strong>：如果一个线程在修改 shared_ptr 的指向时，另一个线程也在修改它，可能会导致引用计数不一致，从而导致内存泄漏或双重释放。</li><li><strong>未定义行为</strong>：访问已释放的内存或访问无效的指针。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// 创建一个 shared_ptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifySharedPtr</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 直接修改 shared_ptr 的指向    </span></span><br><span class="line">    sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);  <span class="comment">// 不安全的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(modifySharedPtr)</span></span>;    </span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(modifySharedPtr)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *sharedPtr &lt;&lt; std::endl;  <span class="comment">// 可能导致未定义行为</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多次运行上面的代码会发现，输出的 <code>value</code> 值有时候会是一个乱码数字，不是预期的 <code>100</code> 。为了避免这些问题，需要使用<code>互斥锁（std::mutex）</code>来同步对 <code>sharedPtr</code> 的修改。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// 创建一个 shared_ptr</span></span><br><span class="line">std::mutex mtx;  <span class="comment">// 互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifySharedPtr</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 加锁    </span></span><br><span class="line">    sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);  <span class="comment">// 安全地修改指向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><ul><li><code>std::weak_ptr</code> 要与 <code>std::shared_ptr</code> 一起使用。 一个 <code>std::weak_ptr</code> 对象看做是 <code>std::shared_ptr</code> 对象管理的资源的观察者，它不影响共享资源的生命周期：<ol><li>如果需要使用 <code>weak_ptr</code> 正在观察的资源，可以将 <code>weak_ptr</code> 提升为 <code>shared_ptr</code></li><li>当 <code>shared_ptr</code> 管理的资源被释放时，<code>weak_ptr</code> 会自动变成 <code>nullptr</code></li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observe</span><span class="params">(std::weak_ptr&lt;<span class="type">int</span>&gt; wptr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> sptr = wptr.<span class="built_in">lock</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; *sptr &lt;&lt; std::endl;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;wptr lock fail&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; wptr;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> sptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">111</span>);</span><br><span class="line">    wptr = sptr;</span><br><span class="line">    <span class="built_in">Observe</span>(wptr);  <span class="comment">// sptr 指向的资源没被释放，wptr 可以成功提升为 shared_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Observe</span>(wptr);  <span class="comment">// sptr 指向的资源已被释放，wptr 无法提升为 shared_ptr</span></span><br></pre></td></tr></table></figure><p><img src="智能指针7.jpg" alt="智能指针7" style="zoom:100%;"></p><ul><li>当 <code>shared_ptr</code> 析构并释放共享资源的时候，只要 <code>weak_ptr</code> 对象还存在，控制块就会保留，<code>weak_ptr</code> 可以通过控制块观察到对象是否存活。</li></ul><p><img src="智能指针8.jpg" alt="智能指针8" style="zoom:100%;"></p><h3 id="enable-shared-from-this"><a href="#enable-shared-from-this" class="headerlink" title="enable_shared_from_this"></a>enable_shared_from_this</h3><ul><li>一个类的成员函数如何获得指向自身（ <code>this</code> ）的 <code>shared_ptr</code> ？</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Foo&gt; <span class="title">GetSPtr</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Foo&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sptr1 = std::<span class="built_in">make_shared</span>&lt;Foo&gt;();</span><br><span class="line"><span class="built_in">assert</span>(sptr<span class="number">1.</span><span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> sptr2 = sptr1-&gt;<span class="built_in">GetSPtr</span>();</span><br><span class="line"><span class="built_in">assert</span>(sptr<span class="number">1.</span><span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br><span class="line"><span class="built_in">assert</span>(sptr<span class="number">2.</span><span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>上面的代码其实会生成两个独立的 <code>shared_ptr</code> ，他们的控制块是独立的，最终导致一个 <code>Foo</code> 对象会被 <code>delete</code> 两次。</li></ul><p><img src="智能指针9.jpg" alt="智能指针9" style="zoom:100%;"></p><ul><li>成员函数获取 <code>this</code> 的 <code>shared_ptr</code> 的正确的做法是继承 <code>std::enable_shared_from_this</code> 。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Bar&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Bar&gt; <span class="title">GetSPtr</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sptr1 = std::<span class="built_in">make_shared</span>&lt;Bar&gt;();</span><br><span class="line"><span class="built_in">assert</span>(sptr<span class="number">1.</span><span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> sptr2 = sptr1-&gt;<span class="built_in">GetSPtr</span>();</span><br><span class="line"><span class="built_in">assert</span>(sptr<span class="number">1.</span><span class="built_in">use_count</span>() == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert</span>(sptr<span class="number">2.</span><span class="built_in">use_count</span>() == <span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li>一般情况下，继承了 <code>std::enable_shared_from_this</code> 的子类，成员变量中会增加一个指向 <code>this</code> 的 <code>weak_ptr</code> 。这个 <code>weak_ptr</code> 在第一次创建 <code>shared_ptr</code> 的时候会被初始化，指向 <code>this</code> 。</li></ul><p><img src="智能指针10.jpg" alt="智能指针10" style="zoom:100%;"></p>]]></content>
      
      
      <categories>
          
          <category> 八股文 - C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左值、右值、纯右值、将亡值</title>
      <link href="//Eight-Part_Essay/C++/Left_Right_Value/"/>
      <url>//Eight-Part_Essay/C++/Left_Right_Value/</url>
      
        <content type="html"><![CDATA[<h2 id="左值、右值、纯右值、将亡值"><a href="#左值、右值、纯右值、将亡值" class="headerlink" title="左值、右值、纯右值、将亡值"></a>左值、右值、纯右值、将亡值</h2><ul><li>C++11使用下面两种独立的性质来区别类别：<ol><li><strong>拥有身份</strong>：指代某个非临时对象。</li><li><strong>可被移动</strong>：可被右值引用类型匹配。</li></ol></li><li>每个C++表达式只属于三种基本值类别中的一种：<code>左值 (lvalue)</code>、<code>纯右值 (prvalue)</code>、<code>将亡值 (xvalue)</code><ol><li>拥有身份且不可被移动的表达式被称作 <code>左值 (lvalue)</code> 表达式，指持久存在的对象或类型为左值引用类型的返还值。</li><li>拥有身份且可被移动的表达式被称作 <code>将亡值 (xvalue)</code> 表达式，一般是指类型为右值引用类型的返还值。</li><li>不拥有身份且可被移动的表达式被称作 <code>纯右值 (prvalue)</code> 表达式，也就是指纯粹的临时值（即使指代的对象是持久存在的）。</li><li>不拥有身份且不可被移动的表达式无法使用。</li></ol></li><li>如此分类是因为移动语义的出现，需要对类别重新规范说明。例如不能简单定义说右值就是临时值（因为也可能是 <code>std::move</code> 过的对象，该代指对象并不一定是临时值）。</li></ul><h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><ol><li>左值是一个数据的表达式（如变量名或引用的指针），我们<strong>可以获取到它的地址</strong>，正常情况下是可以能够对它赋值</li><li><strong>定义const修饰后的左值，不能给它赋值</strong>，但是可以取出它的地址</li><li>左值可以出现在赋值符号<code>（ &quot; = &quot; ）</code>的左边，也可以出现在赋值符号<code>（&quot; = &quot;）</code>的右边</li><li>左值具有持久的状态</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lValue = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* lValueP = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lValueC = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><ol><li>左值引用是对左值的一种引用，相当于给左值取别名</li><li>普通的左值引用不能引用右值，<strong>但是const的左值引用可以引用右值</strong></li><li>引用方法: <code>类型+&amp;</code> ，例如： <code>int&amp; lvalueReferenceP = lValueP</code> ;</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; lValueReference = lValue;</span><br><span class="line"><span class="type">int</span>*&amp; lValueReferenceP = lValueP;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; lValueReferenceC_1 = <span class="number">10</span>; <span class="comment">// const的左值引用，引用右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; lValueReferenceC_2 = <span class="number">10</span> + <span class="number">20</span>; <span class="comment">// const的左值引用，引用右值</span></span><br></pre></td></tr></table></figure><h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><ol><li>右值也是一个数据表达式，右值是<strong>字面常量</strong>或者是求值过程中创建的<strong>临时对象</strong></li><li>右值的生命周期是短暂的，如：<code>字面常量</code>，<code>表达式返回值</code>，<code>函数返回值</code>（不是左值引用的返回值），<code>临时变量</code>，<code>匿名对象</code>等等</li><li>右值不能出现在赋值符号的左边，右值也<strong>不能取出地址</strong>，更<strong>不能对它赋值</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是常见的右值</span></span><br><span class="line">x + y; <span class="comment">// 表达式返回值</span></span><br><span class="line"><span class="built_in">function</span>(x, y); <span class="comment">// 函数返回值</span></span><br><span class="line"><span class="number">10</span>; <span class="comment">// 常量</span></span><br></pre></td></tr></table></figure><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><ol><li>右值引用是给右值取别名，<strong>所有的右值引用是不能引用左值</strong></li><li><strong>右值是不能取出地址的</strong>，但是当右值<strong>取别名后，这个右值会被存到特定的位置，且可以取到该值的地址</strong>，也就是说右值引用值是一个左值</li><li>右值引用会开辟一块空间去存右值，其中普通的右值引用是可以被修改这块空间的，const的右值引用时不可以被修改的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rValueReference = x + y; <span class="comment">// 正确</span></span><br><span class="line">rValueReference = <span class="number">20</span>; <span class="comment">// 正确，普通的右值引用可以被修改</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rValueReference = x; <span class="comment">// 错误，右值引用不能引用左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> rValueReferenceC = <span class="number">10</span>;</span><br><span class="line">rValueReferenceC = <span class="number">30</span>; <span class="comment">// 错误，rValueReferenceC是const右值引用，不能被修改</span></span><br><span class="line"><span class="comment">// 标准库中的move函数可以将一个左值强制转换为右值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rValueReference = <span class="built_in">move</span>(x); <span class="comment">// 正确，move将x转化为右值</span></span><br></pre></td></tr></table></figure><h4 id="右值引用作为函数参数"><a href="#右值引用作为函数参数" class="headerlink" title="右值引用作为函数参数"></a>右值引用作为函数参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似这样的函数可以接受右值参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="右值引用和移动语义"><a href="#右值引用和移动语义" class="headerlink" title="右值引用和移动语义"></a>右值引用和移动语义</h4><ul><li>右值引用与移动语义密切相关。通过使用右值引用，可以实现资源的所有权转移而不进行深层拷贝。这可以通过移动构造函数和移动赋值运算符来实现。右值引用还为实现<code>完美转发（perfect forwarding）</code>提供了支持，这在泛型编程和模板元编程中非常有用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">data</span>(<span class="literal">nullptr</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="built_in">int</span>(value)) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 避免其他对象释放资源时重复释放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move assignment operator called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> data; <span class="comment">// 释放当前对象的资源</span></span><br><span class="line">            data = other.data; <span class="comment">// 转移资源所有权</span></span><br><span class="line">            other.data = <span class="literal">nullptr</span>; <span class="comment">// 避免其他对象释放资源时重复释放</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data) </span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Data: nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">printData</span>(); <span class="comment">// 打印: Data: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用移动构造函数转移资源</span></span><br><span class="line">    MyClass obj2 = std::<span class="built_in">move</span>(obj1);</span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">printData</span>(); <span class="comment">// 打印: Data: 10</span></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">printData</span>(); <span class="comment">// 打印: Data: nullptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用移动赋值运算符转移资源</span></span><br><span class="line">    MyClass obj3;</span><br><span class="line">    obj3 = std::<span class="built_in">move</span>(obj2);</span><br><span class="line">    obj<span class="number">3.</span><span class="built_in">printData</span>(); <span class="comment">// 打印: Data: 10</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">printData</span>(); <span class="comment">// 打印: Data: nullptr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="右值引用注意点"><a href="#右值引用注意点" class="headerlink" title="右值引用注意点"></a>右值引用注意点</h4><ul><li>当你传递一个临时对象（右值）给接受右值引用参数的函数时，该临时对象的生命周期将与函数调用的生命周期绑定在一起。这意味着在函数调用结束后，临时对象将被销毁，因此你不能再安全地访问它。</li></ul><h3 id="std-move-函数"><a href="#std-move-函数" class="headerlink" title="std::move() 函数"></a>std::move() 函数</h3><ul><li><code>std::move()</code> 是一个模板函数，它将一个左值转换为对应的右值引用。这对于支持移动语义很有用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; rx = std::<span class="built_in">move</span>(x); <span class="comment">// 将 x 转换为右值引用</span></span><br></pre></td></tr></table></figure><ul><li><code>std::move()</code> 是一个 C++ 标准库中的函数模板，位于 <code>&lt;utility&gt;</code> 头文件中。它的作用是将一个 <code>左值（lvalue）</code>转换为对应的 <code>右值引用（rvalue reference）</code>，从而允许移动语义的使用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; arg)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>std::move()</code> 函数的定义使用了模板元编程技术，通过参数推导来接受任意类型的参数，并返回对应类型的右值引用。具体来说，<code>std::move()</code> 接受一个参数 <code>arg</code> ，并将其转换为对应类型的右值引用。这个参数可以是任何类型，包括用户定义的类型、标准库类型或者内置类型。</li><li>使用 <code>std::move()</code> 的主要目的是为了支持移动语义。当我们需要将资源从一个对象转移至另一个对象时，通常需要使用移动语义来避免不必要的深层拷贝。<code>std::move()</code> 提供了一种简单的方法来显式表示我们正在进行资源的转移而不是拷贝。</li><li>使用 <code>std::move()</code> 的一般步骤如下：<ol><li>定义一个对象，它包含某种资源（如内存、文件句柄等）;</li><li>当我们确定不再需要原始对象中的资源，并且想要将资源转移到另一个对象时，使用 <code>std::move()</code> 将原始对象转换为右值引用;</li><li>将右值引用传递给接受右值引用参数的构造函数、赋值运算符或者其他函数。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) &#123; std::cout &lt;&lt; <span class="string">&quot;Move constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass original;</span><br><span class="line">    MyClass moved = std::<span class="built_in">move</span>(original); <span class="comment">// 使用 std::move() 将 original 转移为右值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个示例中，当我们使用 <code>std::move(original)</code> 时，<code>original</code> 被显式转换为右值引用，从而调用了移动构造函数。这样，资源可以从 <code>original</code> 对象转移到 <code>moved</code> 对象，而不需要执行深层拷贝。</li><li><strong>需要注意的是，<code>std::move()</code> 本身并不执行任何移动操作，它只是将其参数转换为对应的右值引用，实际的资源转移操作是由接受右值引用的构造函数或者赋值运算符执行的</strong>。</li></ul><h3 id="完美转发（Perfect-Forwarding）"><a href="#完美转发（Perfect-Forwarding）" class="headerlink" title="完美转发（Perfect Forwarding）"></a>完美转发（Perfect Forwarding）</h3><ul><li>为解决 <code>引用折叠</code> 问题，必须写一个任意参数的函数模板，并转发到其他函数。比如当右值引用作为参数时，虽然名义上接收的是右值，但是向下传递时，已经改变为了左值。我们希望左值转发之后还是左值，右值转发后还是右值，我们想让它保持原有的属性。</li></ul><h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><ul><li>引用折叠就是，如果间接创建一个引用的引用， 那么这些引用就会折叠。</li><li>规则：<ol><li><code>&amp;&amp; + &amp;&amp; -&gt; &amp;&amp;</code>：右值的右值引用是右值</li><li><code>&amp;&amp; + &amp; -&gt; &amp;</code>：右值的左值引用是左值</li><li><code>&amp; + &amp;&amp; -&gt; &amp;</code>：左值的右值引用是左值</li><li><code>&amp; + &amp; -&gt; &amp;</code>：左值的左值引用是左值</li></ol></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>左值（lvalue）</strong> 指持久存在（有变量名）的对象或返还值类型为左值引用的返还值，是不可移动的。</li><li><strong>右值（rvalue）</strong> 包含了 <code>将亡值</code>、<code>纯右值</code>，<strong>是可移动（可被右值引用类型匹配）的值</strong>。</li><li>实际上C++ <code>std::move</code> 函数的实现原理就是<strong>强转成右值引用类型并返还之</strong>，因此该返还值会被判断为将亡值，更宽泛的说是被判定为右值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector&amp; <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Vector&amp;&amp; <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Vector <span class="title">func3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector v;</span><br><span class="line"></span><br><span class="line">    v;              <span class="comment">//左值表达式</span></span><br><span class="line">    <span class="built_in">func1</span>();        <span class="comment">//左值表达式，返还值是临时的，返还类型是左值引用，因此被认为不可移动。</span></span><br><span class="line">    <span class="built_in">func2</span>();        <span class="comment">//将亡值表达式，返还值是临时的，返还类型是右值引用，因此指代的对象即使非临时也会被认为可移动。</span></span><br><span class="line">    <span class="built_in">func3</span>();        <span class="comment">//纯右值表达式，返还值为临时值。</span></span><br><span class="line">    std::<span class="built_in">move</span>(v)；  <span class="comment">//将亡值表达式，std::move本质也是个函数，同上。</span></span><br><span class="line">    <span class="built_in">Vector</span>();       <span class="comment">//纯右值表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 八股文 - C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Lambda 相关问题</title>
      <link href="//Eight-Part_Essay/C++/Lambda_Problem/"/>
      <url>//Eight-Part_Essay/C++/Lambda_Problem/</url>
      
        <content type="html"><![CDATA[<h2 id="Lambda-表达式如何对应到函数对象"><a href="#Lambda-表达式如何对应到函数对象" class="headerlink" title="Lambda 表达式如何对应到函数对象"></a>Lambda 表达式如何对应到函数对象</h2><ul><li>在 C++ 中，Lambda 表达式本质上是<strong>编译器生成的匿名函数对象​（又称闭包类）</strong>，其底层实现依赖于对 <code>operator()</code> 运算符的重载。这种机制使得 Lambda 既能保持与普通函数相似的调用方式，又能通过捕获上下文变量实现更灵活的行为。以下是其核心实现原理和对应关系的具体分析:</li></ul><h3 id="Lambda表达式与闭包类的映射"><a href="#Lambda表达式与闭包类的映射" class="headerlink" title="Lambda表达式与闭包类的映射"></a>Lambda表达式与闭包类的映射</h3><ol><li><p><strong>编译器生成的匿名类</strong></p><ul><li><p>当定义一个Lambda表达式时，编译器会隐式生成一个唯一的闭包类，该类包含以下核心结构:</p><ol><li><strong>成员变量</strong>：存储通过值捕获或引用捕获的外部变量（若存在捕获）。</li><li><strong>​重载的operator()</strong>：实现Lambda的函数体逻辑。</li><li><strong>可能的类型转换函数</strong>：用于无捕获Lambda隐式转换为函数指针（通过+运算符触发）。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [x](<span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="comment">// 对于上面的语句，编译器生成类似以下的闭包类：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__lambda_anonymous</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">// 值捕获的变量副本</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    __lambda_anonymous(<span class="type">int</span> x_captured) : <span class="built_in">x</span>(x_captured) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>捕获变量的存储方式</strong></p><ul><li><strong>值捕获</strong>：外部变量被复制为闭包类的成员变量（如int x）。</li><li><strong>​引用捕获</strong>：闭包类中存储对原变量的引用（如int&amp; x）。</li><li><strong>​隐式捕获</strong>：通过[=]或[&amp;]批量捕获作用域内变量，生成对应的成员或引用。</li></ul></li></ol><h3 id="函数对象的调用行为"><a href="#函数对象的调用行为" class="headerlink" title="函数对象的调用行为"></a>函数对象的调用行为</h3><ol><li><p><strong>operator() 的重载规则</strong></p><ul><li>​默认不可修改值捕获变量：若未使用mutable关键字，operator()被标记为const，禁止修改值捕获的变量副本。</li><li>​允许修改的条件：添加 mutable 后，operator()变为非const，可修改值捕获的变量（仅限副本，不影响原变量）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [a]() <span class="keyword">mutable</span> &#123; a++; &#125;;  <span class="comment">// 允许修改副本a</span></span><br></pre></td></tr></table></figure></li><li><p><strong>​与函数指针的兼容性</strong></p><ul><li>无状态Lambda（无捕获）​：可隐式转换为普通函数指针，因其闭包类无成员变量，operator()等价于静态函数。</li><li>有状态Lambda：无法转换为函数指针，必须通过闭包对象调用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无捕获Lambda可转换为函数指针</span></span><br><span class="line"><span class="built_in">void</span> (*func_ptr)(<span class="type">int</span>) = [](<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="comment">// 有捕获Lambda必须作为对象使用</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [y](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + y; &#125;;  <span class="comment">// 无法转换为指针</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Lambda 与 STL 的协同</strong></p><ol><li><p><strong>​作为函数对象适配器</strong></p><ul><li>Lambda 表达式可直接传递给 STL 算法（如std::sort、std::for_each），替代传统的函数对象或函数指针。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br></pre></td></tr></table></figure></li><li><p>​<strong>泛型 Lambda（C++ 14+）​</strong></p><ul><li>通过 auto 参数支持泛型，闭包类的 operator() 被模板化，使其能处理多种类型：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> generic_lambda = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>特殊场景与优化</strong></p><ol><li><p><strong>移动语义与捕获</strong></p><ul><li>使用 std::move 捕获仅移动类型（如std::unique_ptr），避免拷贝开销：\</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">auto</span> lambda = [p = std::<span class="built_in">move</span>(ptr)]() &#123; <span class="comment">/* 使用p */</span> &#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>mutable 的临时修改</strong></p><ul><li>值捕获的变量在 Lambda 内部修改后，其副本的生命周期仅限于闭包对象，外部变量不受影响。</li></ul></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 八股文 - C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字大写转换</title>
      <link href="//Eight-Part_Essay/C++/Digital_Conversion/"/>
      <url>//Eight-Part_Essay/C++/Digital_Conversion/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>该算法未经过大量数据验证！！！</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string chinese[] = &#123;<span class="string">&quot;零&quot;</span>, <span class="string">&quot;一&quot;</span>, <span class="string">&quot;二&quot;</span>, <span class="string">&quot;三&quot;</span>, <span class="string">&quot;四&quot;</span>, <span class="string">&quot;五&quot;</span>, <span class="string">&quot;六&quot;</span>, <span class="string">&quot;七&quot;</span>, <span class="string">&quot;八&quot;</span>, <span class="string">&quot;九&quot;</span>&#125;;</span><br><span class="line">string bit[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;十&quot;</span>, <span class="string">&quot;百&quot;</span>, <span class="string">&quot;千&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">GetChinese</span><span class="params">(string num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stoi</span>(num) == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; i != num.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; num[i + <span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result += <span class="string">&quot;零&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result += chinese[num[i] - <span class="string">&#x27;0&#x27;</span>] + bit[num.<span class="built_in">size</span>() - i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">NumToChinese</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">size</span>() &lt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string gc = <span class="built_in">GetChinese</span>(str);</span><br><span class="line">        <span class="keyword">if</span> (gc == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;零&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> gc;</span><br><span class="line">    &#125;</span><br><span class="line">    string result;</span><br><span class="line">    string thousand = str.<span class="built_in">substr</span>(str.<span class="built_in">size</span>() - <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    result = <span class="built_in">GetChinese</span>(thousand);</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">size</span>() &lt;= <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string tt = str.<span class="built_in">substr</span>(<span class="number">0</span>, str.<span class="built_in">size</span>() - <span class="number">4</span>);</span><br><span class="line">        string gc = <span class="built_in">GetChinese</span>(tt);</span><br><span class="line">        <span class="keyword">if</span> (gc != <span class="string">&quot;&quot;</span>) result = gc + <span class="string">&quot;万&quot;</span> + result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (str.<span class="built_in">size</span>() &gt; <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string tt = str.<span class="built_in">substr</span>(str.<span class="built_in">size</span>() - <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">        string gc = <span class="built_in">GetChinese</span>(tt);</span><br><span class="line">        <span class="keyword">if</span> (gc != <span class="string">&quot;&quot;</span>) result = gc + <span class="string">&quot;万&quot;</span> + result;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NumToChinese</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>, str.<span class="built_in">size</span>() - <span class="number">8</span>)) + <span class="string">&quot;亿&quot;</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> num;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    string result = <span class="built_in">NumToChinese</span>(<span class="built_in">to_string</span>(num));</span><br><span class="line">    cout &lt;&lt; result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 八股文 - C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手撕队列（queue）</title>
      <link href="//Eight-Part_Essay/C++/Custom_Queue/"/>
      <url>//Eight-Part_Essay/C++/Custom_Queue/</url>
      
        <content type="html"><![CDATA[<h2 id="手撕队列（基于数组）"><a href="#手撕队列（基于数组）" class="headerlink" title="手撕队列（基于数组）"></a>手撕队列（基于数组）</h2><ul><li>关键点在于头指针和尾指针在队列清空时的调整（MyQueue::pop()），不当的操作可能导致清空后的空间无法重复使用，不断扩容。</li><li>可对扩容操作（MyQueue::push()）做进一步优化（数据前移）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _data;</span><br><span class="line">    <span class="type">int</span> _front;</span><br><span class="line">    <span class="type">int</span> _rear;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    <span class="type">int</span> _capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>();</span><br><span class="line">    <span class="built_in">MyQueue</span>(<span class="type">int</span> capacity);</span><br><span class="line">    ~<span class="built_in">MyQueue</span>();</span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T num)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyQueue&lt;T&gt;::<span class="built_in">MyQueue</span>() : _front(<span class="number">0</span>), _rear(<span class="number">0</span>), _size(<span class="number">0</span>), _capacity(<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _data = <span class="keyword">new</span> T[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyQueue&lt;T&gt;::<span class="built_in">MyQueue</span>(<span class="type">int</span> capacity) : _front(<span class="number">0</span>), _rear(<span class="number">0</span>), _size(<span class="number">0</span>), _capacity(capacity)</span><br><span class="line">&#123;</span><br><span class="line">    _data = <span class="keyword">new</span> T[capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyQueue&lt;T&gt;::~<span class="built_in">MyQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] _data;</span><br><span class="line">    _data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T MyQueue&lt;T&gt;::<span class="built_in">front</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_size == <span class="number">0</span>) <span class="keyword">throw</span> <span class="string">&quot;队列为空&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> _data[_front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T MyQueue&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_size == <span class="number">0</span>) <span class="keyword">throw</span> <span class="string">&quot;队列为空&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> _data[_rear];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T MyQueue&lt;T&gt;::<span class="built_in">size</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T MyQueue&lt;T&gt;::<span class="built_in">pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_size == <span class="number">0</span>) <span class="keyword">throw</span> <span class="string">&quot;队列为空&quot;</span>;</span><br><span class="line">    T value = _data[_front];</span><br><span class="line">    _front = (_front + <span class="number">1</span>) % _capacity;</span><br><span class="line">    <span class="keyword">if</span> (_front == <span class="number">0</span>) _rear = <span class="number">0</span>;</span><br><span class="line">    --_size;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> MyQueue&lt;T&gt;::<span class="built_in">empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyQueue&lt;T&gt;::<span class="built_in">push</span>(T element)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_rear == _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        _capacity *= <span class="number">2</span>;</span><br><span class="line">        T* newData = <span class="keyword">new</span> T[_capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _rear; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            newData[i] = _data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] _data;</span><br><span class="line">        _data = newData;</span><br><span class="line">        newData = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _data[_rear] = element;</span><br><span class="line">    ++_rear;</span><br><span class="line">    ++_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手撕队列（基于链表）"><a href="#手撕队列（基于链表）" class="headerlink" title="手撕队列（基于链表）"></a>手撕队列（基于链表）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待更新</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 八股文 - C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const 与 static</title>
      <link href="//Eight-Part_Essay/C++/Const_And_Static/"/>
      <url>//Eight-Part_Essay/C++/Const_And_Static/</url>
      
        <content type="html"><![CDATA[<h2 id="const-与-static-关键字"><a href="#const-与-static-关键字" class="headerlink" title="const 与 static 关键字"></a>const 与 static 关键字</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul><li>const修饰符用来定义常量，具有不可变性。在类中，被const修饰的成员函数，不能修改类中的数据成员；</li><li><strong>指针常量</strong>指的是该指针本身是一个常量，不能被修改，但是指针指向的对象可以被修改；</li><li><strong>常量指针</strong>指的是这个指针指向的对象是一个常量，不能被修改，但是指针本身可以被修改。</li><li>如果 const 变量是在<strong>全局作用域</strong>中声明的，它将存储在<strong>静态存储区</strong>（Static Storage Area）中。</li><li>如果 const 变量是在<strong>函数内部或代码块内部</strong>声明的，它将存储在<strong>栈</strong>（Stack）上，在函数返回时释放。</li><li><strong>const 修饰的字符串常量</strong>存储在<strong>常量存储区</strong>，在程序运行期间保持不变。</li></ul><h4 id="const-修饰的函数能否重载？"><a href="#const-修饰的函数能否重载？" class="headerlink" title="const 修饰的函数能否重载？"></a>const 修饰的函数能否重载？</h4><ul><li><strong>const修饰的函数可以重载</strong>。const成员函数既不能改变类内的数据成员，也无法调用非const的成员函数；const类对象只能调用const成员函数。非const对象无论是否是const成员函数都能调用，但是如果有重载的非const函数，非const对象会优先调用重载后的非const函数。</li></ul><h4 id="const-修饰函数的参数"><a href="#const-修饰函数的参数" class="headerlink" title="const 修饰函数的参数"></a>const 修饰函数的参数</h4><ul><li>如果参数作输出用，不论它是什么数据类型，也不论它采用“指针传递”还是“引用传递”，都不能加const修饰，否则该参数将失去输出功能。</li><li>如果输入参数采用“指针传递”，那么加const修饰可以防止意外地改动该指针，起到保护作用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StringCopy</span><span class="params">(<span class="type">char</span>*strDestination, <span class="type">const</span> <span class="type">char</span> *strSource)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const引用传递”，目的是提高效率</strong>。例如将 <code>void Func(A a)</code> 改为 <code>void Func(const A &amp;a)</code>。</li><li><strong>对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性</strong>。例如 <code>void Func(int x)</code> 不应该改为 <code>void Func(const int &amp;x)</code> 。</li></ul><h4 id="const-修饰函数的返回值"><a href="#const-修饰函数的返回值" class="headerlink" title="const 修饰函数的返回值"></a>const 修饰函数的返回值</h4><ul><li>如果给以“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针。例如如下函数：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetString</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>如下语句将出现编译错误：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* str = <span class="built_in">GetString</span>();</span><br></pre></td></tr></table></figure><ul><li>正确的用法时：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="built_in">GetString</span>();</span><br></pre></td></tr></table></figure><ul><li>如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const修饰没有任何价值。　例如：<br>不要将函数 <code>int GetInt(void)</code> 写成 <code>const int GetInt(void)</code>。</li><li>同理不要把函数 <code>A GetA(void)</code> 写成 <code>const A GetA(void)</code> ，其中A为用户自定义的数据类型。</li><li>如果返回值<strong>不是</strong>内部数据类型，将函数 <code>A GetA(void)</code> 改写为 <code>const A&amp; GetA(void)</code> 的确能提高效率。</li><li>但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。</li><li>函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">　　A&amp; operater = (<span class="type">const</span> A &amp;other); <span class="comment">// 赋值函数</span></span><br><span class="line">&#125;;</span><br><span class="line">A  a, b, c;   <span class="comment">// a, b, c 为A的对象</span></span><br><span class="line"> </span><br><span class="line">a = b = c;    <span class="comment">// 正常的链式赋值</span></span><br><span class="line">(a = b) = c;  <span class="comment">// 不正常的链式赋值，但合法</span></span><br></pre></td></tr></table></figure><ul><li>如果将赋值函数的返回值加const修饰，那么该返回值的内容不允许被改动。上例中，语句 <code>a = b = c</code> 仍然正确，但是语句 <code>(a = b) = c</code> 则是非法的。</li></ul><h4 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h4><ul><li>任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其它非const成员函数，编译器将指出错误。</li><li>这无疑会提高程序的健壮性。以下程序中，类stack的成员函数GetCount仅用于计数，从逻辑上讲GetCount应当为const函数。编译器将指出GetCount函数中的错误。</li></ul><h4 id="补充：const放在后面是什么意思？"><a href="#补充：const放在后面是什么意思？" class="headerlink" title="补充：const放在后面是什么意思？"></a>补充：const放在后面是什么意思？</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AcGePoint3dstartPoint</span>() <span class="type">const</span>;</span><br></pre></td></tr></table></figure><ul><li>const放在后面跟前面有区别么？准确的说const是修饰this指向的对象的</li><li>譬如，我们定义了</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">　　<span class="built_in">f</span>(<span class="type">int</span> p);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>这里 <code>f</code> 函数其实有两个参数，第一个是 <code>A* const this</code> , 另一个才是int类型的参数</li><li>如果我们不想 <code>f</code> 函数改变参数的值，可以把函数原型改为 <code>f(const int)</code> ,但如果我们不允许 <code>f</code> 改变this指向的对象呢？因为this是隐含参数，const没法直接修饰它，就加在函数的后面了，表示this的类型是 <code>const A* const this</code>。</li><li>const修饰 <code>*this</code> 是本质，至于说“表示该成员函数不会修改类的数据。否则会编译报错”之类的说法只是一个现象，根源就是因为 <code>*this</code> 是const类型的。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> elem)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Pop</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetCount</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span>; <span class="comment">// const 成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">    <span class="type">int</span> m_data[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::GetCount</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++m_num;      <span class="comment">// 编译错误，企图修改数据成员m_num</span></span><br><span class="line">    <span class="built_in">Pop</span>();        <span class="comment">// 编译错误，企图调用非const函数</span></span><br><span class="line">    <span class="keyword">return</span> m_num;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="静态数据的存储"><a href="#静态数据的存储" class="headerlink" title="静态数据的存储"></a>静态数据的存储</h4><ol><li>static 变量在<strong>类的声明中</strong>不占用内存（未赋值），因此必须在.cpp文件中定义类静态变量以分配内存；</li><li>文件域的静态变量和类的静态成员变量<strong>在main执行之前的静态初始化过程中分配内存并初始化</strong>（已赋值）；</li><li>局部静态变量在<strong>第一次使用时分配内存并初始化</strong>；</li><li>赋予字面值时会在<strong>编译阶段</strong>就被初始化, 加载时将其映射到内存空间。</li><li><strong>全局（静态）存储区</strong>：分为 <code>DATA</code> 段和 <code>BSS</code> 段。<code>DATA</code> 段（全局初始化区）存放初始化的全局变量和静态变量；<code>BSS</code> 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。</li><li>其中 <code>BBS</code> 段在程序执行之前会被系统自动清0，所以<strong>未初始化</strong>的<strong>全局变量和静态变量</strong>在<strong>程序执行之前</strong>已经为0。</li><li>存储在静态数据区的变量会<strong>在程序刚开始运行时</strong>就完成初始化，也是<strong>唯一</strong>的一次初始化。</li><li>在 C++ 中 static 的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。</li></ol><h4 id="static-修饰全局变量"><a href="#static-修饰全局变量" class="headerlink" title="static 修饰全局变量"></a>static 修饰全局变量</h4><ul><li>static 修饰全局变量可以将变量的作用域<strong>限定在当前文件中</strong>，使得其他文件无法访问该变量。</li><li>static 修饰的<strong>全局变量</strong>在<strong>程序启动时被初始化</strong>（可以简单理解为在执行 main 函数之前，会执行一个全局的初始化函数，在那里会执行全局变量的初始化），生命周期和程序一样长。</li></ul><h4 id="static-修饰局部变量"><a href="#static-修饰局部变量" class="headerlink" title="static 修饰局部变量"></a>static 修饰局部变量</h4><ul><li>static 修饰局部变量可以使得变量在函数调用结束后不会被销毁，而是一直存在于内存中，下次调用该函数时可以继续使用。</li><li>由于 static 修饰的局部变量的作用域仅限于函数内部，所以其他函数无法访问该变量。</li></ul><h4 id="static-修饰函数"><a href="#static-修饰函数" class="headerlink" title="static 修饰函数"></a>static 修饰函数</h4><ul><li>static 修饰函数可以将函数的作用域限定在当前文件中，使得其他文件无法访问该函数。</li><li>由于 static 修饰的函数只能在当前文件中被调用，因此可以避免命名冲突和代码重复定义。</li></ul><h4 id="static-修饰类成员变量和函数"><a href="#static-修饰类成员变量和函数" class="headerlink" title="static 修饰类成员变量和函数"></a>static 修饰类成员变量和函数</h4><ul><li>static 修饰类成员变量和函数可以使得它们在所有类对象中共享，且不需要创建对象就可以直接访问。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const 与 constexpr</title>
      <link href="//Eight-Part_Essay/C++/Const_And_Constexpr/"/>
      <url>//Eight-Part_Essay/C++/Const_And_Constexpr/</url>
      
        <content type="html"><![CDATA[<h2 id="const-与-constexpr-的区别"><a href="#const-与-constexpr-的区别" class="headerlink" title="const 与 constexpr 的区别"></a>const 与 constexpr 的区别</h2><ul><li>如下图：</li></ul><p><img src="区别.png" alt="const 与 constexpr 的区别" style="zoom:100%;"></p><ul><li>主要是用于区分<strong>只读变量</strong>和<strong>常量</strong><ol><li><strong>只读变量</strong>：运行时确定</li><li><strong>常量</strong>：编译时确定</li><li>性能方面：常量 &gt; 只读变量</li></ol></li></ul><h3 id="常见的常量表达式"><a href="#常见的常量表达式" class="headerlink" title="常见的常量表达式"></a>常见的常量表达式</h3><ol><li>字面值（如 42）</li><li>用常量表达式初始化的对象</li></ol><ul><li>一个对象（或表达式）是否是常量表达式取决于类型和初始值，如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i1 = <span class="number">42</span>;           <span class="comment">// i1 不是常量表达式：初始值 42 是字面值，但 i1 不是 const / constexpr 类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i2 = i1;     <span class="comment">// i2 不是常量表达式：初始值 i1 不是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i3 = <span class="number">42</span>;     <span class="comment">// i3 是常量表达式：用字面值 42 初始化的 const 对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i4 = i3 + <span class="number">1</span>; <span class="comment">// i4 是常量表达式：用常量表达式 i3 + 1 初始化的 const 对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i5 = <span class="built_in">getValue</span>(); <span class="comment">// 如果 getValue() 是普通函数，则 i5 值要到运行时才能确定，则不是常量表达式。相反，如果 getValue() 是 const 或 constexpr 类型，则 i5 是常量表达式，编译时即可确定</span></span><br></pre></td></tr></table></figure><h3 id="constexpr-变量"><a href="#constexpr-变量" class="headerlink" title="constexpr 变量"></a>constexpr 变量</h3><ul><li><p>上面的例子可以看出，不能直接判断一个 const 对象是否是常量表达式：例如 i4 是否是常量表达式取决于 i3 是否是常量表达式，而 i4 又可能用来初始化其他常量表达式。在复杂的系统中，很难一眼看出某个 const 对象是否是常量表达式。</p></li><li><p>C++11 允许把变量声明为 constexpr 类型，此时编译器会保证 constexpr 变量是常量表达式（否则编译报错）。换句话说，只要看到 constexpr 类型的变量，则一定能够在编译期取得结果，可以用在需要常量表达式的场景。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i2 = i1; <span class="comment">// constexpr 变量 &#x27;i2&#x27; 必须由常量表达式初始化。不允许在常量表达式中读取非 const / constexpr 变量 &#x27;i1&#x27;</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i3 = <span class="number">42</span>; <span class="comment">// i3 是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i4 = i3 + <span class="number">1</span>; <span class="comment">// i4 是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i5 = <span class="built_in">getValue</span>(); <span class="comment">// 只有 getValue() 是 constexpr 函数时才可以，否则编译报错</span></span><br></pre></td></tr></table></figure><h3 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a>constexpr 函数</h3><ul><li>constexpr 函数是指能用于常量表达式的函数。需要强调的是，constexpr 函数既能用于要求常量表达式 / 编译期常量的语境，也可以作为普通函数使用。</li><li><strong>注意：constexpr 函数不一定返回常量表达式</strong>！只有 constexpr 的所有实参都是常量表达式 / 编译期常量时，constexpr 函数的结果才是常量表达式/编译期常量。只要有一个参数在编译期未知，那就和普通函数一样，在运行时计算。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i2 = <span class="built_in">sum</span>(i1, <span class="number">52</span>); <span class="comment">// 所有参数都是常量表达式，sum 的结果也是常量表达式，在编译期求值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">AddThree</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sum</span>(i, <span class="number">3</span>); &#125; <span class="comment">// i 不是常量表达式，此时 sum 作为普通函数使用</span></span><br></pre></td></tr></table></figure><h3 id="constexpr-限制"><a href="#constexpr-限制" class="headerlink" title="constexpr 限制"></a>constexpr 限制</h3><ul><li>因为需要在编译期求值，所以 constexpr 函数有一些限制：返回类型和所有形参的类型必须是字面值类型（literal type）。除了内置类型，用户自定义的类也可以是字面值类型，因为它的构造函数和成员函数也可以是 constexpr 函数。</li></ul><h3 id="使用-constexpr-的好处"><a href="#使用-constexpr-的好处" class="headerlink" title="使用 constexpr 的好处"></a>使用 constexpr 的好处</h3><ul><li>编译器可以保证 constexpr 对象是常量表达式（能够在编译期取得结果），而 const 对象不能保证。如果一个 const 变量能够在编译期求值，将其改为 constexpr 能够让代码更清晰易读</li><li>constexpr 函数可以把运行期计算迁移至编译期，使得程序运行更快（但会增加编译时间）</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>修饰对象的时候，可以把 constexpr 当作加强版的 const。<strong>const 对象只表明值不会改变，不一定能够在编译期取得结果</strong>。</li><li><strong>constexpr 对象不仅值不会改变，而且保证能够在编译期取得结果</strong>。constexpr 函数既可以用于编译期计算，也可以作为普通函数在运行期使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股文 - C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎玉零珠———— C++</title>
      <link href="//Eight-Part_Essay/C++/Broken_Jade_Beads/"/>
      <url>//Eight-Part_Essay/C++/Broken_Jade_Beads/</url>
      
        <content type="html"><![CDATA[<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li><code>volatile</code> 是 C 语言中的一个关键字，用于修饰变量，表示该变量的值可能在任何时候被外部因素更改，例如 <code>硬件设备</code>、<code>操作系统</code> 或 <code>其他线程</code> 。</li><li>当一个变量被声明为 <code>volatile</code> 时，编译器会禁止对该变量进行优化，以确保<strong>每次访问</strong>变量时都会<strong>从内存中读取其值</strong>，而不是从寄存器或缓存中读取。避免因为编译器优化而导致出现不符合预期的结果。</li></ul><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><ul><li>在 C++ 中，<code>explicit</code> 通常用于构造函数的声明中，用于<strong>防止隐式转换</strong>。 当将一个参数传递给构造函数时，如果构造函数声明中使用了 <code>explicit</code> 关键字，则只能使用显式转换进行转换，而不能进行隐式转换。这种机制可以防止编译器自动执行预期外的类型转换，提高代码的安全性。</li></ul><h3 id="什么是隐式类型转化"><a href="#什么是隐式类型转化" class="headerlink" title="什么是隐式类型转化"></a>什么是隐式类型转化</h3><ul><li>当你只有一个类型T1，但是当前表达式需要类型为T2的值，如果这时候T1自动转换为了T2，那么这就是隐式类型转换。如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> b = a + <span class="number">1</span>; <span class="comment">// int 转换为 long</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (a == b) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 默认的operator==需要a的类型和b相同，因此也发生转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="explicit的作用"><a href="#explicit的作用" class="headerlink" title="explicit的作用"></a>explicit的作用</h3><ul><li>有一个类 <code>MyInt</code> ，表示一个整数，并且有一个构造函数可以将 <code>int</code> 类型的参数转换为 <code>MyInt</code> 类型：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInt</span>(<span class="type">int</span> n) : <span class="built_in">num</span>(n) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>我们可以使用下面的代码来创建一个 <code>MyInt</code> 对象（不考虑编译器优化，编译器会用复制省略（copy elision）优化这段代码，最终不会有中间这个临时对象产生）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyInt a = <span class="number">10</span>; <span class="comment">// 注意，这段代码有两个步骤： 1. int 类型的 10 先隐式类型转换为 MyInt 的一个临时对象</span></span><br><span class="line">              <span class="comment">// 2. 隐式类型转换后的临时对象再通过复制构造函数生成 a</span></span><br></pre></td></tr></table></figure><ul><li>在一些情况下，上面这种隐式转换可能会导致问题。 例如，考虑下面的函数：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(MyInt n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这也会编译通过，因为编译器会将 <code>int</code> 类型的值隐式转换为 <code>MyInt</code> 类型的对象。</li><li>但或许，有些情况下，我们并不期望 <code>f</code> 函数可以接受一个 <code>int</code> 类型的参数，这是预期外的，可能会导致错误的结果。那么如果希望只接受 <code>MyInt</code> 类型的参数，就可以将构造函数声明加上 <code>explicit</code>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyInt</span><span class="params">(<span class="type">int</span> n)</span> : num(n) &#123;</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="built_in">MyInt</span>(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样，上面的调用语句将会导致编译错误，因为不能使用隐式转换将 <code>int</code> 类型的值转换为 <code>MyInt</code> 类型。必须使用显式转换。</li><li>所以大家日常可以使用 <code>explicit</code> 关键字可以防止不必要的隐式转换，提高代码的可读性和安全性。尤其是<strong>构造函数参数只有一种类型</strong>的，强烈建议加上 <code>explicit</code>。</li></ul><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a><span id="extern">extern</span></h2><ul><li>一般而言，C++全局变量的作用范围仅限于当前的文件，但同时C++也支持分离式编译，允许将程序分割为若干个文件被独立编译。于是就需要在文件间共享变量数据，这里 <code>extern</code> 就发挥了作用。</li><li><code>extern</code> 用于指示变量或函数的定义在另一个源文件中，并在当前源文件中声明。 说明该符号具有外部链接 <code>(external linkage)</code> 属性。也就是告诉编译器: 这个符号在别处定义了，你先编译，到时候链接器会去别的地方找这个符号定义的地址。</li></ul><h3 id="符号的声明与定义"><a href="#符号的声明与定义" class="headerlink" title="符号的声明与定义"></a>符号的声明与定义</h3><ul><li><strong>声明</strong>：告诉编译器某个符号的存在，在程序变量表中记录类型和名字。</li><li><strong>定义</strong>：为该符号分配内存空间或实现其代码逻辑。</li><li><strong>凡是没有带 <code>extern</code> 的声明同时也都是定义</strong>。对函数而言，带有 <code>&#123;&#125;</code> 是定义，否则是声明。如果想声明一个变量而非定义它，就在变量名前添加关键字 <code>extern</code> ，且不要显式的初始化变量。</li></ul><h4 id="变量的声明与定义"><a href="#变量的声明与定义" class="headerlink" title="变量的声明与定义"></a>变量的声明与定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> global_var;</span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="type">int</span> global_var = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><ul><li>在上面的示例中，<code>global_var</code> 变量的声明使用 <code>extern</code> 关键字告诉编译器它的定义在当前或其它源文件中，而定义则是为变量分配内存空间并初始化为 <code>42</code> 。</li></ul><h4 id="函数的声明和定义"><a href="#函数的声明和定义" class="headerlink" title="函数的声明和定义"></a>函数的声明和定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在上面的示例中，<code>sum</code> 函数的声明告诉编译器该函数的存在及其参数和返回值类型，而定义则是实现函数的代码逻辑。</li></ul><h3 id="C-C-中的链接属性"><a href="#C-C-中的链接属性" class="headerlink" title="C/C++中的链接属性"></a>C/C++中的链接属性</h3><ul><li><a href="待补充">编译与链接</a>（待补充）</li><li>在 C++ 中，链接属性是指程序在编译、链接和执行阶段如何处理符号（变量、函数、类等）的可见性和重复定义。 C++ 语言规定有以下链接属性：<ol><li><strong>外部链接（External Linkage）</strong>：外部链接的符号可以在不同的源文件之间共享，并且在整个程序执行期间可见。全局变量和函数都具有外部链接。</li><li><strong>内部链接（Internal Linkage）</strong>：内部链接的符号只能在当前源文件内部使用，不能被其他源文件访问。用 <code>static</code> 修饰的全局变量和函数具有内部链接。</li><li><strong>无链接（No Linkage）</strong>：无链接的符号只能在当前代码块（函数或代码块）内部使用，不能被其他函数或代码块访问。用 <code>const</code> 或 <code>constexpr</code> 修饰的常量具有无链接属性（ 通常情况下编译器是不会为const对象分配内存，也就无法链接）</li><li><strong>外部 C 链接（External C Linkage）</strong>：外部 C 链接的符号与外部链接类似，可以在不同的源文件之间共享，并且在整个程序执行期间可见。它们具有 C 语言的名称和调用约定，可以与 C 语言编写的代码进行交互。在 C++ 中，可以用 <code>extern &quot;C&quot;</code> 关键字来指定外部 C 链接，从而使用一些 C 的静态库。这些链接属性可以通过关键字 <code>extern</code> 、<code>static</code> 、<code>const</code> 和 <code>extern &quot;C&quot;</code> 来显式地指定。</li></ol></li></ul><h3 id="extern-的作用"><a href="#extern-的作用" class="headerlink" title="extern 的作用"></a>extern 的作用</h3><h4 id="声明变量但不定义"><a href="#声明变量但不定义" class="headerlink" title="声明变量但不定义"></a>声明变量但不定义</h4><ul><li>声明变量或函数的存在，但不进行定义，让编译器在链接时在其他源文件中查找定义。这使得不同的源文件可以共享相同的变量或函数。当链接器在一个全局变量声明前看到 <code>extern</code> 关键字，它会尝试在其他文件中寻找这个变量的定义。这里强调全局且非常量的原因是，全局非常量的变量默认是外部链接的。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fileA.cpp</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;              <span class="comment">//声明并定义全局变量i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fileB.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;           <span class="comment">//声明i，链接全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fileC.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i = <span class="number">2</span>;       <span class="comment">//错误，多重定义</span></span><br><span class="line"><span class="type">int</span> i;                  <span class="comment">//错误，这是一个定义，导致多重定义</span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> i;       <span class="comment">//正确</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">5</span>;          <span class="comment">//正确，新的局部变量i;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常量全局变量的外部链接"><a href="#常量全局变量的外部链接" class="headerlink" title="常量全局变量的外部链接"></a>常量全局变量的外部链接</h4><ul><li>全局常量默认是内部链接的，所以想要在文件间传递全局常量量需要在定义时指明   <code>extern</code> ，如下所示：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fileA.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;        <span class="comment">//定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fileB.cpp                    </span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> i;            <span class="comment">//声明</span></span><br></pre></td></tr></table></figure><ul><li>而下面这种用法则会报链接错误，找不到 <code>i</code> 的定义：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fileA.cpp</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;        <span class="comment">//定义 (不用 extern 修饰)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fileB.cpp                    </span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> i;     <span class="comment">//声明</span></span><br></pre></td></tr></table></figure><h4 id="编译和链接过程"><a href="#编译和链接过程" class="headerlink" title="编译和链接过程"></a>编译和链接过程</h4><ul><li>编译链接过程中，<code>extern</code> 的作用如下：<ol><li>在<strong>编译期</strong>，<code>extern</code> 用于告诉编译器某个变量或函数的定义在其他源文件中，编译器会为它生成一个符号表项，并在当前源文件中建立一个对该符号的引用。这个引用是一个未定义的符号，编译器在后续的链接过程中会在其他源文件中查找这个符号的定义。</li><li>在<strong>链接期</strong>，链接器将多个目标文件合并成一个可执行文件，并且在当前源文件中声明的符号，会在其它源文件中找到对应的定义，并将它们链接起来。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> global_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; global_var &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="type">int</span> global_var = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><ul><li>在上面的示例中，<code>file1.cpp</code> 文件中的 <code>main</code> 函数使用了全局变量 <code>global_var</code> ，但是 <code>global_var</code> 的定义是在 <code>file2.cpp</code> 中的，因此在 <code>file1.cpp</code> 中需要使用 <code>extern</code> 声明该变量。</li><li>在<strong>编译</strong>时，编译器会为 <code>global_var</code> 生成一个符号表项，并在 <code>file1.cpp</code> 中建立一个对该符号的引用。</li><li>在<strong>链接</strong>时，链接器会在其他源文件中查找 <code>global_var</code> 的定义，并将其链接起来。</li></ul><h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><ul><li>正如这篇文章 <a href="#extern">extern</a> 所说，<code>extern</code> 是指示链接可见性和符号规则，而 <code>extern &quot;C&quot;</code> 则是 C++ 语言提供的一种机制，用于在 C++ 代码中调用 C 语言编写的函数和变量。如果不用 <code>extern &quot;C&quot;</code>，由于 C++ 和 C 语言在编译和链接时使用的命名规则不同，这会导致 C++ 代码无法调用 C 语言编写的函数或变量（链接时找不到符号）。</li></ul><h3 id="函数的命名规则"><a href="#函数的命名规则" class="headerlink" title="函数的命名规则"></a>函数的命名规则</h3><ul><li>对于 C++ 语言，<strong>由于需要支持重载</strong>，所以一个函数的链接名（Linkage Name）是由函数的名称、参数类型和返回值类型等信息组成的，<strong>用于在编译和链接时唯一标识该函数</strong>。</li><li>函数的链接名的生成规则在不同的编译器和操作系统上可能有所不同，一般是由编译器自动处理，不需要手动指定，这个规则常常叫做 <a href="https://en.wikipedia.org/wiki/Name_mangling">Name Mangling</a></li><li>下面介绍一些常见的规则：<ol><li><strong>Microsoft Visual C++ 编译器（Windows）</strong>：函数的名称会被编译器修改为一个以 “_” 开头的名称，并加上参数类型和返回值类型等信息，以避免链接冲突。例如，函数 <code>int add(int a, int b)</code> 的链接名可能是 <code>_add_int_int</code>。</li><li><strong>GCC 编译器（Linux）</strong>：也会加上参数类型和返回值类型等信息。例如，函数 <code>int add(int a, int b)</code> 的链接名可能是 <code>_Z3addii</code>。</li><li><strong>Clang 编译器（MacOS）</strong>：函数的链接名的生成规则与 GCC 编译器类似，但稍有不同。例如，函数 <code>int add(int a, int b)</code> 的链接名可能是 <code>_Z3addii</code>。</li></ol></li><li>而 C 语言的链接函数名规则又和 上面三个 C++ 不一样，通过在 C++ 代码中使用 <code>extern &quot;C&quot;</code> 关键字，可以将 C++ 编译器的命名规则转换为 C 语言的命名规则，从而使得 C++ 代码可以调用 C 语言的函数或变量。</li></ul><h3 id="extern-“C”语法"><a href="#extern-“C”语法" class="headerlink" title="extern “C”语法"></a>extern “C”语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extern &quot;C&quot; 的语法格式如下：</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// C 语言函数或变量的声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>extern &quot;C&quot;</code> 声明的函数或变量会采用 C 语言的链接规则，即符号的名称和调用约定与 C 语言相同。下面是一个代码示例。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 语言代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_message</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 代码</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明 C 语言函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用 C 语言函数</span></span><br><span class="line">    <span class="built_in">print_message</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在上面的代码中，使用 <code>extern &quot;C&quot;</code> 声明了 C 语言编写的 <code>print_message</code> 函数，使得它可以在 C++ 代码中被调用。在 <code>main</code> 函数中，使用 C 语言的语法和命名规则来调用 <code>print_message</code> 函数，输出 <code>&quot;Hello, world!&quot;</code>。</li><li>需要注意 <code>extern &quot;C&quot;</code> 关键字<strong>只对函数的名称和调用约定起作用，对于函数的参数类型和返回值类型没有影响</strong>。所以，在使用 <code>extern &quot;C&quot;</code> 声明函数时，需要保证函数的参数类型和返回值类型与 C 语言的定义相同，否则可能会导致编译错误或运行时错误。</li></ul><h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><ul><li><code>mutable</code> 是C++中的一个关键字，用于修饰类的成员变量，表示该成员变量即使在一个 <code>const</code> 成员函数中也可以被修改。<code>mutable</code> 的中文意思是“可变的，易变的”，跟 <code>constant</code>（即 C++ 中的 <code>const</code>）是反义词。因为在 C++ 中，如果一个成员函数被声明为 <code>const</code>，那么它不能修改类的任何成员变量，除非这个成员变量被声明为 <code>mutable</code> 。</li><li>这个关键字主要应用场景是：如果需要在 <code>const</code> 函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被 <code>mutable</code> 来修饰，并且放在函数后后面关键字位置。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() : <span class="built_in">count</span>(<span class="number">0</span>), <span class="built_in">cache_valid</span>(<span class="literal">false</span>), <span class="built_in">cached_value</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_count</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache_valid) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模拟一个耗时的计算过程</span></span><br><span class="line">            cached_value = count * <span class="number">2</span>;</span><br><span class="line">            cache_valid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cached_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        cache_valid = <span class="literal">false</span>; <span class="comment">// 使缓存无效，因为count已经更改</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> cache_valid; <span class="comment">// 缓存是否有效的标志</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> cached_value; <span class="comment">// 缓存的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Counter counter;</span><br><span class="line">    counter.<span class="built_in">increment</span>();</span><br><span class="line">    counter.<span class="built_in">increment</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; counter.<span class="built_in">get_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面定义了一个 <code>Counter</code> 类，该类具有一个计数成员变量 <code>count</code> 。还有两个 <code>mutable</code> 成员变量：<code>cache_valid</code> 和 <code>cached_value</code> 。这两个变量用于在 <code>get_count</code> 函数中缓存计算结果，从而提高性能。<code>get_count</code> 函数被声明为 <code>const</code> ，因为它在逻辑上不会更改类的状态。然而，需要更新 <code>cache_valid</code> 和 <code>cached_value</code> 变量以提高性能。为了在 <code>const</code> 成员函数中修改这两个变量，将它们声明为 <code>mutable</code> 。</li><li>这个例子不那么贴切的展示了 <code>mutable</code> 关键字的用途：即允许在 <code>const</code> 成员函数中修改特定的成员变量，以支持内部实现所需的功能，同时仍然保持外部不变性。</li></ul><h2 id="malloc-与-new"><a href="#malloc-与-new" class="headerlink" title="malloc 与 new"></a>malloc 与 new</h2><ul><li>C使用malloc / free, C++使用new / delete, 前者是C语言中的库函数，后者是C++语言的运算符</li><li>对于自定义对象，malloc/free只进行分配内存和释放内存，无法调用其构造函数和析构函数</li><li>只有new/delete能做到，完成对象的空间分配和初始化，以及对象的销毁和释放空间</li><li>所以二者<strong>不可混用</strong></li><li>具体区别如下：<ol><li>new分配内存空间无需指定分配内存大小，malloc需要；</li><li>new返回类型指针，类型安全，malloc返回void*，再强制转换成所需要的类型；</li><li>new是从自由存储区获得内存，malloc从堆中获取内存；</li><li>对于类对象，new会调用构造函数和析构函数，malloc不会（核心）。</li></ol></li></ul><h2 id="inline-与-define"><a href="#inline-与-define" class="headerlink" title="inline 与 define"></a>inline 与 define</h2><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><ul><li>使编译器在函数调用点上展开函数，可以避免函数调用的栈开销；</li><li>内联函数的<strong>缺点</strong>是可能造成代码膨胀，尤其是递归的函数，会造成大量内存开销，exe太大，占用CPU资源。此外，内联函数不方便调试，每次修改会<strong>重新编译</strong>文件，<strong>增加编译时间</strong>。</li></ul><h4 id="inline-一定会展开吗？"><a href="#inline-一定会展开吗？" class="headerlink" title="inline 一定会展开吗？"></a>inline 一定会展开吗？</h4><ul><li><strong>内联函数仅仅是对编译器的内联建议</strong>，编译器是否觉得采取你的建议取决于函数是否符合内联的有利条件。如果函数体非常大（超过10行），那么编译器将忽略函数的内联声明，而将内联函数作为普通函数处理。</li></ul><h4 id="构造函数和析构函数适合内联吗？"><a href="#构造函数和析构函数适合内联吗？" class="headerlink" title="构造函数和析构函数适合内联吗？"></a>构造函数和析构函数适合内联吗？</h4><ul><li>构造函数和析构函数<strong>不适合</strong>内联。</li><li>构造函数不适合的原因是：即使是看似琐碎或空的构造函数通常也可能包含大量由编译器隐式生成的代码，而实际的构造函数可能会非常大，这可能会导致代码膨胀。</li><li>析构函数不适合的原因是：它可能是虚函数。</li></ul><h4 id="虚函数可以内联吗？"><a href="#虚函数可以内联吗？" class="headerlink" title="虚函数可以内联吗？"></a>虚函数可以内联吗？</h4><ul><li>虚函数可能可以内联（会不会内联要分情况讨论）。</li><li>可以被内联：当虚函数被调用时它的入口地址是在编译阶段静态确定的，那么就可能会被内联。参考 <a href="/Eight-Part_Essay/C++/Virtual_Call/">虚调用</a></li><li>不可以被内联：当虚函数使用父类的指针或者引用，动态地调用子类的虚函数功能时，由于inline是在编译器将函数内容替换到函数调用处，是静态编译的，而此时虚函数是动态调用的，编译器并不知道需要调用的是父类还是子类的虚函数，所以不能够inline声明展开，故编译器会忽略。</li></ul><h4 id="其它不适合内联的情况"><a href="#其它不适合内联的情况" class="headerlink" title="其它不适合内联的情况"></a>其它不适合内联的情况</h4><ul><li>内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行)：因为如果内联函数本身就很复杂，那么将导致调用该内联函数的函数更为复杂，内存处理上更麻烦，可能会让程序整体的效率更低下。</li><li>通常递归函数不应该声明成内联函数，大多数编译器都不支持内联递归函数：因为递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的。</li></ul><h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><ul><li>define宏命令是在预处理阶段对命令进行替换，inline是在编译阶段在函数调用点处直接展开函数，节省了函数调用的栈开销；</li><li>define<strong>不会</strong>对参数的类型进行检查的，因此会出现类型安全的问题。比如定义一个max命令，但是传递的时候可能会传递一个整数和一个字符串，就会出错；</li><li>内联函数在编译阶段会进行类型检查；</li><li>使用宏的时候可能要添加很多括号，比较容易出错。</li></ul><h2 id="define-与-typedef-的区别"><a href="#define-与-typedef-的区别" class="headerlink" title="define 与 typedef 的区别"></a>define 与 typedef 的区别</h2><ul><li>语法和实现机制：<ol><li>宏定义 #define 在编译期间将宏展开，并替换宏定义中的代码。<strong>预处理器只进行简单的文本替换，不涉及类型检查</strong>。</li><li>typedef 是一种类型定义关键字，用于为现有类型创建新的名称（别名）。<strong>与宏定义不同，typedef 是在编译阶段处理的，有更严格的类型检查</strong>。</li></ol></li><li>作用域限制：<ol><li>宏定义没有作用域限制，只要在宏定义之后的地方，就可以使用宏。</li><li>typedef 遵循 C++ 的作用域规则，可以受到命名空间、类等结构的作用域限制。</li></ol></li><li><p>模板支持：</p><ol><li>宏定义不支持模板，因此不能用于定义模板类型别名。</li><li>typedef 可以与模板结合使用，但在 C++11 之后，推荐使用 using 关键字定义模板类型别名。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 typedef 定义模板类型别名</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyContainer</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::vector&lt;T&gt; Type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 using 定义模板类型别名（C++11 及以后）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyContainer</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Type = std::vector&lt;T&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="C-的声明定义与内存之间的关系"><a href="#C-的声明定义与内存之间的关系" class="headerlink" title="C++的声明定义与内存之间的关系"></a>C++的声明定义与内存之间的关系</h2><ul><li>局部变量：声明和定义在调用的时候同时进行内存分配。</li><li>全局变量：声明的时候不分配内存，定义的时候分配内存(注意，此处的全局变量是指多个文件调用，使用extern声明的。如果只单个文件调用，还是局部变量一样)。</li><li>函数：声明和定义的时候不分配内存，调用的时候分配内存。</li><li>结构体：声明和定义的时候不分配内存，实例化的时候分配内存。</li><li>类：声明和定义的时候不分配内存，实例化的时候分配内存。</li></ul><h2 id="动态库与静态库的区别"><a href="#动态库与静态库的区别" class="headerlink" title="动态库与静态库的区别"></a>动态库与静态库的区别</h2><p><img src="动态库与静态库的区别.png" alt="动态库与静态库的区别" style="zoom:50%;"></p><h2 id="两个线程各进行100次i-操作后i的值是多少"><a href="#两个线程各进行100次i-操作后i的值是多少" class="headerlink" title="两个线程各进行100次i++操作后i的值是多少"></a>两个线程各进行100次i++操作后i的值是多少</h2><p><img src="两个线程进行i++.jpg" alt="两个线程进行i++" style="zoom:50%;"></p><h2 id="继承时一般要写类的哪些成员函数？"><a href="#继承时一般要写类的哪些成员函数？" class="headerlink" title="继承时一般要写类的哪些成员函数？"></a>继承时一般要写类的哪些成员函数？</h2><p><img src="默认成员函数.png" alt="默认成员函数" style="zoom:50%;"></p><h2 id="怎样让对象只能创建在栈-堆-内存池中"><a href="#怎样让对象只能创建在栈-堆-内存池中" class="headerlink" title="怎样让对象只能创建在栈/堆/内存池中"></a>怎样让对象只能创建在栈/堆/内存池中</h2><ul><li>在c++中，类的对象建立分为两种，一种是静态建立，比如</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br></pre></td></tr></table></figure><ul><li>另一种是动态建立，比如</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A* ptr = <span class="keyword">new</span> A;</span><br></pre></td></tr></table></figure><ul><li>这两种方式是有区别的。</li><li><strong>静态建立类对象</strong>： 是由编译器为对象在栈空间中分配内存，通过移动栈顶指针挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。这种方式是直接调用类的构造函数。</li><li><strong>动态建立类对象</strong>： 是用new关键字将对象建立在堆空间上，这个过程分两步走。首先是执行 operator new() 函数，在堆空间上搜索合适的内存并分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方式是间接的调用类的构造函数。</li></ul><h3 id="只在栈上分配内存"><a href="#只在栈上分配内存" class="headerlink" title="只在栈上分配内存"></a>只在栈上分配内存</h3><ul><li><strong>只有使用new运算符，对象才会建立在堆上</strong>，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new，而后者我们是可以自行声明重写的。</li><li>因此，将operator new()设为私有即可禁止对象被new在堆上。</li><li>代码如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> t)</span></span>&#123;&#125;     <span class="comment">// 注意函数的第一个参数和返回值都是固定的  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span></span>&#123;&#125;  <span class="comment">// 重载了new就需要重载delete  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="只在堆上分配内存"><a href="#只在堆上分配内存" class="headerlink" title="只在堆上分配内存"></a>只在堆上分配内存</h3><ul><li>首先要知道，当对象建立在栈上面时, 是由编译器分配内存空间的，当对象使用完以后，编译器会调用析构函数来释放对象所占的空间。</li><li>实际上，编译器在为类对象分配栈空间时, 会检查类的析构函数的访问性(其他非静态函数也会检查)，如果类的析构函数是私有的， 则编程器不会在栈空间上为类对象分配内存。</li><li>因此, 我们只需要将析构函数设为私有，类对象就无法建立在栈上了。</li><li>代码如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;<span class="keyword">delete</span> <span class="keyword">this</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：由于new表达式会在分配内存以后调用构造函数，因此构造函数必须是公有的。同时由于delete此时无法访问私有的析构函数，因此必须提供一个destroy函数，来进行内存空间的释放。</li></ul><h3 id="由此引发的其它问题"><a href="#由此引发的其它问题" class="headerlink" title="由此引发的其它问题"></a>由此引发的其它问题</h3><ol><li><strong>无法解决继承问题</strong>：为了实现多态，析构函数通常要设为virtual，因此析构函数不能设为private，此时我们可以使用protected， 这样，子类可以访问析构函数，而外部无法访问。</li><li>new 和 destroy 的对应关系容易引起误解，解决办法是将构造函数也设置为protected，然后提供一个create函数和destroy对应。</li></ol><h2 id="红黑树的插入与删除（速记版）"><a href="#红黑树的插入与删除（速记版）" class="headerlink" title="红黑树的插入与删除（速记版）"></a>红黑树的插入与删除（速记版）</h2><p><img src="红黑树插入.jpg" alt="红黑树的插入" style="zoom:50%;"><br><img src="红黑树删除.jpg" alt="红黑树的删除" style="zoom:50%;"></p><h2 id="字节对齐规则"><a href="#字节对齐规则" class="headerlink" title="字节对齐规则"></a>字节对齐规则</h2><h3 id="自然对齐规则"><a href="#自然对齐规则" class="headerlink" title="自然对齐规则"></a>自然对齐规则</h3><ul><li>对于基本数据类型，其自然对齐边界通常为其大小。</li><li>例如，char 类型的自然对齐边界为 1 字节，short 为 2 字节，int 和 float 为 4 字节，double 和 64 位指针为 8 字节。具体数值可能因编译器和平台而异。</li></ul><h3 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h3><ul><li>结构体内部的每个成员都根据其 <code>自然对齐</code> 边界进行对齐。也就是可能在成员之间插入填充字节。</li><li>结构体本身的总大小也会根据其最大对齐边界的成员进行对齐（比如结构体成员包含的最长类型为int类型，那么整个结构体要按照4的倍数对齐），以便在数组中正确对齐。</li></ul><h3 id="联合体对齐"><a href="#联合体对齐" class="headerlink" title="联合体对齐"></a>联合体对齐</h3><ul><li>联合体的对齐边界取决于其最大对齐边界的成员。联合体的大小等于其最大大小的成员，因为联合体的所有成员共享相同的内存空间。</li></ul><h3 id="编译器指令"><a href="#编译器指令" class="headerlink" title="编译器指令"></a>编译器指令</h3><ul><li>可以使用编译器指令（如 <code>#pragma pack</code> ）更改默认的对齐规则。这个命令是全局生效的。这可以用于减小数据结构的大小，但可能会降低访问性能。</li></ul><h3 id="对齐属性"><a href="#对齐属性" class="headerlink" title="对齐属性"></a>对齐属性</h3><ul><li>在 C++11 及更高版本中，可以使用 <code>alignas</code> 关键字为数据结构或变量指定对齐要求。这个命令是对某个类型或者对象生效的。例如，<code>alignas(16) int x</code> ; 将确保 <code>x</code> 的地址是 16 的倍数。</li></ul><h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><ul><li>大多数内存分配函数（如 malloc 和 new）会自动分配足够对齐的内存，以满足任何数据类型的对齐要求。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1) <span class="comment">// 设置字节对齐为 1 字节，取消自动对齐</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnalignedStruct</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop) <span class="comment">// 恢复默认的字节对齐设置</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AlignedStruct</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;   <span class="comment">// 本来1字节，padding 3 字节</span></span><br><span class="line">    <span class="type">int</span> b;    <span class="comment">//  4 字节</span></span><br><span class="line">    <span class="type">short</span> c;  <span class="comment">// 本来 short 2字节，但是整体需要按照 4 字节对齐(成员对齐边界最大的是int 4)，所以需要padding 2</span></span><br><span class="line">    <span class="comment">// 总共: 4 + 4 + 4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> a;    <span class="comment">// 8 个字节</span></span><br><span class="line">    <span class="type">char</span> b;      <span class="comment">// 本来占一个字节，但是接下来的 int 需要起始地址为4的倍数</span></span><br><span class="line">                  <span class="comment">//所以这里也会加3字节的padding</span></span><br><span class="line">    <span class="type">int</span> c;       <span class="comment">// 4 个字节</span></span><br><span class="line">    <span class="comment">// 总共:  8 + 4 + 4 = 16</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct1</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> b;    <span class="comment">// 本来1个字节 + 7个字节padding</span></span><br><span class="line">    <span class="type">double</span> a;  <span class="comment">// 8 个字节</span></span><br><span class="line">    <span class="type">int</span> c;     <span class="comment">// 本来 4 个字节，但是整体要按 8 字节对齐，所以 4个字节padding</span></span><br><span class="line">    <span class="comment">// 总共: 8 + 8 + 8 = 24</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of unaligned struct: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(UnalignedStruct) &lt;&lt; std::endl; </span><br><span class="line">    <span class="comment">// 输出：7</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of aligned struct: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(AlignedStruct) &lt;&lt; std::endl; </span><br><span class="line">    <span class="comment">// 输出：12，取决于编译器和平台</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of aligned struct: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(MyStruct) &lt;&lt; std::endl; </span><br><span class="line">    <span class="comment">// 输出：16，取决于编译器和平台</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of aligned struct: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(MyStruct1) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 输出：24，取决于编译器和平台</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大小端-字节序"><a href="#大小端-字节序" class="headerlink" title="大小端 ( 字节序 )"></a>大小端 ( 字节序 )</h2><ul><li>字节序是指在多字节数据类型（如整数、浮点数等）中，字节在内存中的存储顺序。</li><li>主要有两种字节序：大端字节序（Big-endian）和小端字节序（Little-endian）。</li></ul><h3 id="大端字节序（Big-endian）"><a href="#大端字节序（Big-endian）" class="headerlink" title="大端字节序（Big-endian）"></a>大端字节序（Big-endian）</h3><ul><li>高位字节存储在低地址处，低位字节存储在高地址处。例如，一个4字节的整数0x12345678，在大端字节序的系统中，内存布局如下（从左侧的低地址到右侧的高地址）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x12</span> | <span class="number">0x34</span> | <span class="number">0x56</span> | <span class="number">0x78</span></span><br></pre></td></tr></table></figure><ul><li>大端字节序是符合人类阅读习惯的顺序。</li></ul><h3 id="小端字节序（Little-endian）"><a href="#小端字节序（Little-endian）" class="headerlink" title="小端字节序（Little-endian）"></a>小端字节序（Little-endian）</h3><ul><li>低位字节存储在低地址处，高位字节存储在高地址处。</li><li>例如，一个4字节的整数0x12345678，在小端字节序的系统中，内存布局如下（从左侧的低地址到右侧的高地址）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x78</span> | <span class="number">0x56</span> | <span class="number">0x34</span> | <span class="number">0x12</span></span><br></pre></td></tr></table></figure><ul><li>判断系统的字节序的方法有多种，下面是一个简单的 C++ 代码示例：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将int类型指针转换为char类型指针，取第一个字节</span></span><br><span class="line">    <span class="type">char</span>* ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*ptr == <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Little-endian&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Big-endian&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这段代码的原理就是，整数 <code>num</code> 值初始化为1（0x00000001）。然后将其指针类型从 <code>int*</code> 转换为 <code>char*</code>，这样我们就可以访问该整数的第一个字节。</li></ul><h3 id="常见的大小端字节序"><a href="#常见的大小端字节序" class="headerlink" title="常见的大小端字节序"></a>常见的大小端字节序</h3><ul><li>在计算机领域中，不同的系统、平台和协议使用不同的字节序。下面是一些常见情况的字节序：</li></ul><h4 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h4><ul><li>在网络传输过程中，通常使用大端字节序（Big-endian），也称为网络字节序，这是 TCP/IP 协议的规定，多字节数据在网络上传输时使用大端字节序。</li><li>因此，如果本地系统使用的是小端字节序，那么就需要在传输之前将其转换为大端字节序。一般通过使用 <code>htonl()</code> 、<code>htons()</code>、<code>ntohl()</code> 和 <code>ntohs()</code> 等函数来完成。</li></ul><h4 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h4><ul><li>在网络传输中，通常使用大端字节序（网络字节序）。</li><li>在具体的操作系统中，字节序取决于底层硬件架构。例如，Linux和Windows操作系统主要运行在x86和x86_64（Intel和AMD处理器）架构上，这些处理器使用小端字节序。</li><li>而其他硬件平台，如PowerPC和SPARC等，可能使用大端字节序。</li></ul><h2 id="栈的效率为什么比堆高？为什么栈的运行速度比堆快？"><a href="#栈的效率为什么比堆高？为什么栈的运行速度比堆快？" class="headerlink" title="栈的效率为什么比堆高？为什么栈的运行速度比堆快？"></a>栈的效率为什么比堆高？为什么栈的运行速度比堆快？</h2><ul><li>这里说的 <code>堆</code> 和 <code>栈</code>，并不是数据结构上的 <code>Heap</code> 跟 <code>Stack</code> ，而是程序运行中的不同内存空间。（例如 C++ 的内存四区：代码区、全局区、堆、栈）</li></ul><ol><li><strong>申请速度快</strong>：栈是程序运行前就已经分配好的空间，所以运行时分配几乎不需要时间。而堆是运行时动态申请的，相当于将分配内存的耗时由编译阶段转嫁到了机器运行阶段，将分配过程从编译器搬到了运行的代码中。于是动态分配的速度不仅与分配算法有关，还与机器运行速度有关。（栈是编译时分配空间，而堆是动态分配（运行时分配空间），所以栈的申请速度快）</li><li><strong>存储寻址速度快</strong>：栈的物理地址空间是连续的，而堆未必，查找堆的链表也会耗费较多时间，所以存储寻址速度慢。</li><li><strong>CPU 硬件操作速度快</strong>：CPU 有专门的寄存器（ <code>esp</code>，<code>ebp</code> ）来操作栈，堆是使用间接寻址的，所以栈快。</li></ol><h3 id="既然栈的运行速度更快，为什么不多用栈呢？"><a href="#既然栈的运行速度更快，为什么不多用栈呢？" class="headerlink" title="既然栈的运行速度更快，为什么不多用栈呢？"></a>既然栈的运行速度更快，为什么不多用栈呢？</h3><ul><li>栈的地址空间必须连续，如果任其任意成长，会给内存管理带来困难。</li><li>对于多线程程序来说，每个线程都必须分配一个栈，因此没办法让默认值太大。</li><li>现代化的内存分配器通过类似slab allocator这样的设计已经尽可能令相关数据尽可能放在一起，从 CPU 数据缓存角度，绝大多数程序并不需要在栈上分配内存，且栈缓冲区溢出的后果比堆缓冲区溢出要严重许多，而在堆上分配缓冲区则可以避免前者。</li><li>PS：任何情况下必须满足下列不等式：<code>堆栈地址最大值 × 线程数目最大值 &lt; 用户态内存地址最大值</code></li></ul><h2 id="C-编译和链接"><a href="#C-编译和链接" class="headerlink" title="C++ 编译和链接"></a>C++ 编译和链接</h2><ol><li><strong>预处理 ( Preprocessing )</strong>：<ul><li>任务：预处理器的任务是处理源代码中的预处理指令，如宏定义（#define）、文件包含（#include）、条件编译（#ifdef、#ifndef、#endif等）指令。它会删除所有注释，展开所有宏定义，处理条件编译指令，并插入包含文件的内容。</li><li>生成文件：预处理后的文件通常以 .i 或 .ii 结尾（在C/C++中），这是预处理后的文本文件，仍然保持高级语言的形式。</li></ul></li><li><strong>编译 ( Compilation )</strong>：<ul><li>任务：编译器将预处理后的源代码转换成汇编语言。这个过程包括词法分析、语法分析、语义分析、中间代码生成、代码优化等步骤。编译器检查源代码中的错误，如语法错误、类型错误等，并将源代码转换成汇编指令。</li><li>生成文件：编译阶段生成的文件通常称为目标文件（Object File），以 .s结尾。这个文件包含机器代码，但是它还不能直接执行（计算机无法识别），因为它可能包含未解析的符号引用。</li></ul></li><li><strong>汇编 ( Assembly )</strong>：<ul><li>任务：汇编器将汇编语言转换成机器语言。它将汇编指令转换成对应的二进制代码，并处理与特定硬件平台相关的指令。</li><li>生成文件：汇编阶段生成的是机器码，它通常被直接存储在目标文件中，所以这个步骤可能不会生成新的文件，而是更新之前编译阶段生成的 .o 或 .obj 文件。</li></ul></li><li><strong>链接 ( Linking )</strong>：<ul><li>任务：链接器将一个或多个目标文件以及所需的库文件组合成一个完整的可执行程序。这个过程包括地址和空间分配、符号决议、重定位等。链接器确保所有外部引用的函数和变量都有正确的地址，并解决不同目标文件之间的依赖关系。</li><li>生成文件：链接阶段生成的最终文件是可执行文件，在Unix/Linux系统中通常以 .out 或 .exe 结尾，在Windows系统中通常以 .exe 结尾。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 八股文 - C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 定义CSS变量，方便统一修改 */:root {  --trans-light: rgba(255, 255, 255, 0.75); /* 白天模式带透明度的背景色 */  --trans-dark: rgba(25, 25, 25, 0.6); /* 夜间模式带透明度的背景色 */  --border-style: 1px solid rgb(169, 169, 169); /* 边框样式 */  --backdrop-filter: blur(15px) saturate(150%); /* 背景过滤器，实现亚克力效果 */}/* 鼠标样式 */#cursor {  position: fixed;  width: 16px;  height: 16px;  /* 这里改变跟随的底色 */  background: rgb(57, 197, 187);  border-radius: 8px;  opacity: 0.25;  z-index: 10086;  pointer-events: none;  transition: 0.2s ease-in-out;  transition-property: background, opacity, transform;}  #cursor.hidden {  opacity: 0;}  #cursor.hover {  opacity: 0.1;  transform: scale(2.5);  -webkit-transform: scale(2.5);  -moz-transform: scale(2.5);  -ms-transform: scale(2.5);  -o-transform: scale(2.5);}  #cursor.active {  opacity: 0.5;  transform: scale(0.5);  -webkit-transform: scale(0.5);  -moz-transform: scale(0.5);  -ms-transform: scale(0.5);  -o-transform: scale(0.5);}/* 页脚与头图透明 */#footer {  background: transparent !important;}/* #page-header {  background: transparent !important;} *//* 白天模式遮罩透明 */#footer::before {  background: transparent !important;}/* #page-header::before {  background: transparent !important;} *//* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}/* [data-theme="dark"] #page-header::before {  background: transparent !important;} *//* 一般状态 */[data-theme="dark"] .magnet_link_context {  background: #1e1e1e;  color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {  background: #3ecdf1;  color: #f2f2f2;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: 'ZZZ';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/zzz.ttf);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 导航栏魔改 *//* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {  left: -38px;}/* 黑夜霓虹灯 *//* 夜间模式菜单栏发光字 */[data-theme="dark"] #nav .site-page,[data-theme="dark"] #nav .menus_items .menus_item .menus_item_child li a {  text-shadow: 0 0 2px rgb(179, 71, 241) !important;}/* 手机端适配 */[data-theme="dark"] #sidebar #sidebar-menus .menus_items .site-page {  text-shadow: 0 0 2px rgb(179, 71, 241) !important;}/* Butterfly 个人卡片：从左下到右上自然流动的渐变 */:root{  --card-pink: #FFADF7;  --card-green: #B1FF96;  --card-anim-duration: 15s; /* 更长的动画时间使流动更自然 */  --card-text-shadow: 0 1px 2px rgba(0,0,0,.25);}html[data-theme="dark"]{  --card-pink: #203a43;  --card-green: #2c5364;  --card-anim-duration: 15s;}#aside-content .card-widget.card-info{  position: relative;  overflow: hidden;  border-radius: 14px;  border: 1px solid rgba(255,255,255,.08);    /* 使用多层渐变创造更丰富的效果 */  background:     linear-gradient(135deg, var(--card-pink), transparent 70%),    linear-gradient(225deg, var(--card-green), transparent 70%),    linear-gradient(315deg, var(--card-pink), transparent 70%),    linear-gradient(45deg, var(--card-green), transparent 70%);    background-size: 400% 400%;  animation: cardFlow var(--card-anim-duration) ease-in-out infinite;    color: #fff;  box-shadow: 0 10px 28px rgba(0,0,0,.16);  will-change: background-position;}/* 柔光层提升质感 */#aside-content .card-widget.card-info::before{  content: '';  position: absolute;  inset: 0;  background:     radial-gradient(ellipse at left bottom, rgba(255,255,255,.4) 0%, transparent 60%),    radial-gradient(ellipse at right top, rgba(255,255,255,.2) 0%, transparent 40%);  mix-blend-mode: soft-light;  pointer-events: none;}/* 悬停微动效 */#aside-content .card-widget.card-info:hover{  transform: translateY(-1px);  box-shadow: 0 14px 34px rgba(0,0,0,.22);}/* 卡片内文字样式 */#aside-content .card-widget.card-info,#aside-content .card-widget.card-info a,#aside-content .card-widget.card-info .author-info__name,#aside-content .card-widget.card-info .author-name,#aside-content .card-widget.card-info .info,#aside-content .card-widget.card-info .item-headline{  color: #fff !important;  text-shadow: var(--card-text-shadow);}/* 头像样式 *//* #aside-content .card-widget.card-info .avatar-img img,#aside-content .card-widget.card-info .avatar-img,#aside-content .card-widget.card-info .author-avatar img,#aside-content .card-widget.card-info .author-avatar{  border-radius: 50%;  border: 2px solid rgba(255,255,255,.75);  box-shadow: 0 10px 22px rgba(0,0,0,.28);} *//* 关键帧动画 - 更复杂的流动效果 */@keyframes cardFlow{  0% {    background-position: 0% 0%, 100% 100%, 0% 100%, 100% 0%;  }  25% {    background-position: 50% 50%, 50% 50%, 100% 0%, 0% 100%;  }  50% {    background-position: 100% 100%, 0% 0%, 50% 50%, 50% 50%;  }  75% {    background-position: 50% 50%, 100% 0%, 0% 100%, 50% 50%;  }  100% {    background-position: 0% 0%, 100% 100%, 0% 100%, 100% 0%;  }}/* 添加一个额外的伪元素来增强流动感 */#aside-content .card-widget.card-info::after{  content: '';  position: absolute;  inset: 0;  background: linear-gradient(135deg,     transparent 0%,     rgba(255,255,255,.1) 50%,     transparent 100%);  animation: shineEffect calc(var(--card-anim-duration) * 2) ease-in-out infinite;  pointer-events: none;}@keyframes shineEffect{  0% {    transform: translateX(-100%) translateY(-100%) rotate(45deg);  }  100% {    transform: translateX(100%) translateY(100%) rotate(45deg);  }}/* 页面样式调节 *//* 通过CSS样式调节各个页面透明度、模糊度(亚克力效果)、圆角、边框样式等 *//* 首页文章卡片样式 */#recent-posts > .recent-post-item {  background: var(--trans-light); /* 使用白天模式透明背景 */  backdrop-filter: var(--backdrop-filter); /* 应用背景过滤器 */  border-radius: 25px; /* 圆角大小 */  border: var(--border-style); /* 边框样式 */}/* 首页侧栏卡片样式 */#aside-content .card-widget {  background: var(--trans-light); /* 使用白天模式透明背景 */  backdrop-filter: var(--backdrop-filter); /* 应用背景过滤器 */  border-radius: 18px; /* 圆角大小 */  border: var(--border-style); /* 边框样式 */}/* 文章页、归档页、普通页面样式 */div#post,div#page,div#archive {  background: var(--trans-light); /* 使用白天模式透明背景 */  backdrop-filter: var(--backdrop-filter); /* 应用背景过滤器 */  border: var(--border-style); /* 边框样式 */  border-radius: 20px; /* 圆角大小 */}/* 导航栏样式 */#page-header .nav-fixed #nav {  background: rgba(255, 255, 255, 0.75); /* 导航栏背景色 */  backdrop-filter: var(--backdrop-filter); /* 应用背景过滤器 */}/* 夜间模式导航栏样式 */[data-theme="dark"] #page-header .nav-fixed #nav {  background: rgba(0, 0, 0, 0.7) !important; /* 深色背景 */}/* 夜间模式遮罩 - 为各种元素应用夜间模式背景 */[data-theme="dark"] #recent-posts > .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {  background: var(--trans-dark); /* 使用夜间模式透明背景 */}/* 夜间模式页脚遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}/* 阅读模式样式 - 侧栏卡片 */.read-mode #aside-content .card-widget {  background: rgba(158, 204, 171, 0.5) !important; /* 柔和的绿色背景 */}/* 阅读模式样式 - 文章页面 */.read-mode div#post {  background: rgba(158, 204, 171, 0.5) !important; /* 柔和的绿色背景 */}/* 夜间模式下的阅读模式 - 侧栏卡片 */[data-theme="dark"] .read-mode #aside-content .card-widget {  background: rgba(25, 25, 25, 0.9) !important; /* 深色背景 */  color: #ffffff; /* 白色文字 */}/* 夜间模式下的阅读模式 - 文章页面 */[data-theme="dark"] .read-mode div#post {  background: rgba(25, 25, 25, 0.9) !important; /* 深色背景 */  color: #ffffff; /* 白色文字 */}/* 菜单栏图标大小 */svg.menu_icon {  width: 1.28em;  height: 1.28em;  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;}/* 社交图标大小 */svg.social_icon {  width: 1.28em;  height: 1.28em;  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/runtime.min.css"/>
      <url>/css/runtime.min.css</url>
      
        <content type="html"><![CDATA[/* 页脚计时器与徽标样式 - 玻璃态设计 */:root {  --primary-bg: rgba(255, 255, 255, 0.75);  --primary-text: #2c3e50;  --accent-color: #3498db;  --card-shadow: rgba(0, 0, 0, 0.1);  --card-border: rgba(255, 255, 255, 0.9);  --badge-bg: rgba(255, 255, 255, 0.9);  --transition-speed: 0.3s;}[data-theme="dark"] {  --primary-bg: rgba(30, 30, 30, 0.8);  --primary-text: #f8f8f2;  --accent-color: #6cb6ff;  --card-shadow: rgba(0, 0, 0, 0.3);  --card-border: rgba(100, 100, 100, 0.3);  --badge-bg: rgba(50, 50, 50, 0.9);}/* 计时器容器样式 */#runtime {  display: flex;  justify-content: center;  align-items: center;  margin: 1.5rem 0;  padding: 1rem;  border-radius: 16px;  background: var(--primary-bg);  backdrop-filter: blur(10px);  -webkit-backdrop-filter: blur(10px);  border: 1px solid var(--card-border);  box-shadow: 0 8px 32px var(--card-shadow);  transition: all var(--transition-speed) ease;}#runtime:hover {  transform: translateY(-5px);  box-shadow: 0 12px 36px var(--card-shadow);}/* 计时器文本 */#runtime-text {  font-size: 1rem;  font-weight: 500;  color: var(--primary-text);  margin-right: 0.5rem;}/* 计时器数字 */#runtime {  font-size: 1.2rem;  font-weight: bold;  color: var(--accent-color);}/* 徽标容器样式 */.footer-badges {  display: flex;  flex-wrap: wrap;  justify-content: center;  gap: 0.8rem;  margin: 1.5rem 0;  padding: 1rem;  border-radius: 16px;  background: var(--primary-bg);  backdrop-filter: blur(10px);  -webkit-backdrop-filter: blur(10px);  border: 1px solid var(--card-border);  box-shadow: 0 8px 32px var(--card-shadow);  transition: all var(--transition-speed) ease;}.footer-badges:hover {  transform: translateY(-5px);  box-shadow: 0 12px 36px var(--card-shadow);}/* 单个徽标样式 */.badge-item {  display: inline-flex;  align-items: center;  padding: 0.5rem 0.8rem;  border-radius: 12px;  background: var(--badge-bg);  backdrop-filter: blur(4px);  -webkit-backdrop-filter: blur(4px);  border: 1px solid var(--card-border);  box-shadow: 0 4px 12px var(--card-shadow);  transition: all 0.2s ease;  text-decoration: none;  color: var(--primary-text);  font-size: 0.85rem;  font-weight: 500;}.badge-item:hover {  transform: translateY(-3px) scale(1.05);  box-shadow: 0 6px 16px var(--card-shadow);  color: var(--accent-color);  text-decoration: none;}/* 徽标图片样式 */.badge-item img {  height: 20px;  margin-right: 0.5rem;  transition: transform 0.2s ease;}.badge-item:hover img {  transform: scale(1.1);}/* 工具提示样式 */.badge-item {  position: relative;}.badge-item::after {  content: attr(data-message);  position: absolute;  bottom: 100%;  left: 50%;  transform: translateX(-50%) translateY(-10px);  padding: 0.5rem 0.8rem;  border-radius: 6px;  background: rgba(0, 0, 0, 0.8);  color: white;  font-size: 0.75rem;  white-space: nowrap;  opacity: 0;  visibility: hidden;  transition: all 0.2s ease;  pointer-events: none;  z-index: 100;}.badge-item:hover::after {  opacity: 1;  visibility: visible;  transform: translateX(-50%) translateY(-5px);}/* 响应式设计 */@media (max-width: 768px) {  #runtime {    flex-direction: column;    padding: 0.8rem;  }    #runtime-text {    margin-right: 0;    margin-bottom: 0.5rem;  }    .footer-badges {    gap: 0.6rem;    padding: 0.8rem;  }    .badge-item {    padding: 0.4rem 0.6rem;    font-size: 0.8rem;  }    .badge-item img {    height: 18px;  }}@media (max-width: 480px) {  .footer-badges {    gap: 0.4rem;  }    .badge-item {    padding: 0.3rem 0.5rem;    font-size: 0.75rem;  }    .badge-item img {    height: 16px;    margin-right: 0.3rem;  }}/* 动画效果 */@keyframes fadeIn {  from {    opacity: 0;    transform: translateY(20px);  }  to {    opacity: 1;    transform: translateY(0);  }}#runtime, .footer-badges {  animation: fadeIn 0.6s ease-out;}/* 轮播模式下的样式调整 */.footer-badges.swiper-mode {  overflow: hidden;}.footer-badges.swiper-mode .badge-item {  flex: 0 0 auto;}/* 打印样式 */@media print {  #runtime, .footer-badges {    display: none;  }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(57, 197, 187)'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光 */#universe {    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的,-1在文章页下面，背景上面，个人推荐这种 */    z-index: 1;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[var now = new Date();function createtime() {    now.setTime(now.getTime() + 1000);    var e = new Date("08/01/2022 00:00:00"),        t = Math.trunc(234e8 + (now - e) / 1000 * 17),        a = (t / 1496e5).toFixed(6),        o = new Date("08/09/2022 00:00:00"),        n = (now - o) / 1000 / 60 / 60 / 24,        r = Math.floor(n),        i = (now - o) / 1000 / 60 / 60 - 24 * r,        s = Math.floor(i);    1 == String(s).length && (s = "0" + s);    var d = (now - o) / 1000 / 60 - 1440 * r - 60 * s,        l = Math.floor(d);    1 == String(l).length && (l = "0" + l);    var g = (now - o) / 1000 - 86400 * r - 3600 * s - 60 * l,        b = Math.round(g);    1 == String(b).length && (b = "0" + b);    let c = "";    c = s < 18 && s >= 9 ?         `<div style="font-size:13px;font-weight:bold">本站运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀</div>` :        `<div style="font-size:13px;font-weight:bold">本站运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀</div>`;    document.getElementById("workboard") && (document.getElementById("workboard").innerHTML = c)}setInterval(() => {createtime()}, 1000);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/light.js"/>
      <url>/js/light.js</url>
      
        <content type="html"><![CDATA[// 霓虹灯效果 - 修复版// 颜色数组var arr = ["#39c5bb", "#f14747", "#f1a247", "#f1ee47", "#b347f1", "#1edbff", "#ed709b", "#5636ed"];// 颜色索引var idx = 0;// 切换颜色function changeColor() {  // 仅夜间模式才启用  if (document.documentElement.getAttribute('data-theme') == 'dark') {    // 查找标题元素 - 修复了选择器问题    var siteNameElem = document.querySelector('#blog-info .site-name');        if (siteNameElem) {      siteNameElem.style.textShadow = arr[idx] + " 0 0 15px";    }        // 其他元素（如果有）    var siteTitleElem = document.getElementById("site-title");    if (siteTitleElem) {      siteTitleElem.style.textShadow = arr[idx] + " 0 0 15px";    }        var siteSubtitleElem = document.getElementById("site-subtitle");    if (siteSubtitleElem) {      siteSubtitleElem.style.textShadow = arr[idx] + " 0 0 10px";    }        var postInfoElem = document.getElementById("post-info");    if (postInfoElem) {      postInfoElem.style.textShadow = arr[idx] + " 0 0 5px";    }        // 作者信息（如果有）    try {      var authorNameElem = document.getElementsByClassName("author-info__name")[0];      var authorDescElem = document.getElementsByClassName("author-info__description")[0];      if (authorNameElem) authorNameElem.style.textShadow = arr[idx] + " 0 0 12px";      if (authorDescElem) authorDescElem.style.textShadow = arr[idx] + " 0 0 12px";    } catch (e) {      // 忽略错误    }        idx++;    if (idx == 8) {      idx = 0;    }  } else {    // 白天模式恢复默认    var siteNameElem = document.querySelector('#blog-info .site-name');    if (siteNameElem) {      siteNameElem.style.textShadow = "#1e1e1ee0 1px 1px 1px";    }        var siteTitleElem = document.getElementById("site-title");    if (siteTitleElem) {      siteTitleElem.style.textShadow = "#1e1e1ee0 1px 1px 1px";    }        var siteSubtitleElem = document.getElementById("site-subtitle");    if (siteSubtitleElem) {      siteSubtitleElem.style.textShadow = "#1e1e1ee0 1px 1px 1px";    }        var postInfoElem = document.getElementById("post-info");    if (postInfoElem) {      postInfoElem.style.textShadow = "#1e1e1ee0 1px 1px 1px";    }        try {      var authorNameElem = document.getElementsByClassName("author-info__name")[0];      var authorDescElem = document.getElementsByClassName("author-info__description")[0];      if (authorNameElem) authorNameElem.style.textShadow = "";      if (authorDescElem) authorDescElem.style.textShadow = "";    } catch (e) {      // 忽略错误    }  }}// 确保DOM完全加载后再执行document.addEventListener('DOMContentLoaded', function() {  // 初始检查一次  changeColor();  // 开启计时器  setInterval(changeColor, 1200);});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark(){    window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;    var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];    function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}    function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}    function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}    function m(t){return Math.floor(1e3*Math.random())+1<10*t}    function l(t,i){return Math.random()*(i-t)+t}    f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>图集</title>
      <link href="/mapdepot/index.html"/>
      <url>/mapdepot/index.html</url>
      
        <content type="html"><![CDATA[<div class = "gallery-group-main"><figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='/%3Chttps:/source.fomal.cc/img/default_cover_61.webp%3E' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">封面专区</div>  <p>本站用作文章封面的图片，不保证分辨率</p>  <a href='/box/Gallery/photo'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='/%3Chttps:/source.fomal.cc/img/dm11.webp%3E' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">背景专区</div>  <p>收藏的一些的背景与壁纸，分辨率很高</p>  <a href='/box/Gallery/wallpaper'></a>  </figcaption>  </figure>  </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movie/index.html"/>
      <url>/movie/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>子页面</title>
      <link href="/subinterface/index.html"/>
      <url>/subinterface/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-container" data-type="data" data-button="">      <div class="gallery-data">[]</div>      <div class="gallery-items">      </div>    </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
